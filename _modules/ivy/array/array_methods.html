<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ivy.array.array_methods &mdash; Ivy 1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="icon" type="image/png" href="https://github.com/unifyai/unifyai.github.io/blob/master/img/externally_linked/ivy_logo_only.png?raw=true">
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Ivy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../background.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../related_work.html">Related Work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions.html">Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deep_dive.html">Deep Dive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/experimental.html">Experimental</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/compilation.html">Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/constants.html">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/creation.html">Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/data_type.html">Data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/elementwise.html">Elementwise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/general.html">General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/gradients.html">Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/linear_algebra.html">Linear algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/losses.html">Losses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/manipulation.html">Manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/meta.html">Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/nest.html">Nest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/random.html">Random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/searching.html">Searching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/sorting.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/statistical.html">Statistical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/utility.html">Utility</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../data_classes/container.html">Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_classes/array.html">Array</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Framework Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/optimizers.html">Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/initializers.html">Initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/sequential.html">Sequential</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/module.html">Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/converters.html">Converters</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ivy"">Ivy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mech"">Ivy mech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../vision"">Ivy vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../robot"">Ivy robot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gym"">Ivy gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory"">Ivy memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../builder"">Ivy builder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models"">Ivy models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ecosystem"">Ivy ecosystem</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ivy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>ivy.array.array_methods</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ivy.array.array_methods</h1><div class="highlight"><pre>
<span></span><span class="c1">#ivy.array.activations</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<div class="viewcode-block" id="relu"><a class="viewcode-back" href="../../../functional/ivy/activations/relu/relu_array.html#ivy.array.array_methods.relu">[docs]</a><span class="k">def</span> <span class="nf">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.relu. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.relu also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="leaky_relu"><a class="viewcode-back" href="../../../functional/ivy/activations/leaky_relu/leaky_relu_array.html#ivy.array.array_methods.leaky_relu">[docs]</a><span class="k">def</span> <span class="nf">leaky_relu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.leaky_relu. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.leaky_relu also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.39, -0.85])</span>
<span class="sd">    &gt;&gt;&gt; y = x.leaky_relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.39, -0.17])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gelu"><a class="viewcode-back" href="../../../functional/ivy/activations/gelu/gelu_array.html#ivy.array.array_methods.gelu">[docs]</a><span class="k">def</span> <span class="nf">gelu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">approximate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gelu. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.gelu also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.3, -0.1])</span>
<span class="sd">    &gt;&gt;&gt; y = x.gelu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.185, -0.046])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sigmoid"><a class="viewcode-back" href="../../../functional/ivy/activations/sigmoid/sigmoid_array.html#ivy.array.array_methods.sigmoid">[docs]</a><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sigmoid. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sigmoid also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sigmoid()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.269, 0.731, 0.881])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/softmax/softmax_array.html#ivy.array.array_methods.softmax">[docs]</a><span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.softmax. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.softmax also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the softmax should be computed</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the softmax unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.422, 0.155, 0.422])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="softplus"><a class="viewcode-back" href="../../../functional/ivy/activations/softplus/softplus_array.html#ivy.array.array_methods.softplus">[docs]</a><span class="k">def</span> <span class="nf">softplus</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.softplus. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.softplus also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-0.3461, -0.6491])</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus(beta=0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.22, 1.09])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.31, 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus(threshold=2, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([1.55, 2.13, 2.13])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log_softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/log_softmax/log_softmax_array.html#ivy.array.array_methods.log_softmax">[docs]</a><span class="k">def</span> <span class="nf">log_softmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log_softmax.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for ivy.log_softmax also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.0, -0.98, 2.3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log_softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-3.37, -3.35, -0.0719])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2.0, 3.4, -4.2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log_softmax(x)</span>
<span class="sd">    ivy.array([-1.62, -0.221, -7.82 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.array</span>
<span class="c1"># flake8: noqa</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">.conversions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.activations</span> <span class="kn">import</span> <span class="n">ArrayWithActivations</span>
<span class="kn">from</span> <span class="nn">.creation</span> <span class="kn">import</span> <span class="n">ArrayWithCreation</span>
<span class="kn">from</span> <span class="nn">.data_type</span> <span class="kn">import</span> <span class="n">ArrayWithDataTypes</span>
<span class="kn">from</span> <span class="nn">.device</span> <span class="kn">import</span> <span class="n">ArrayWithDevice</span>
<span class="kn">from</span> <span class="nn">.elementwise</span> <span class="kn">import</span> <span class="n">ArrayWithElementwise</span>
<span class="kn">from</span> <span class="nn">.general</span> <span class="kn">import</span> <span class="n">ArrayWithGeneral</span>
<span class="kn">from</span> <span class="nn">.gradients</span> <span class="kn">import</span> <span class="n">ArrayWithGradients</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">ArrayWithImage</span>
<span class="kn">from</span> <span class="nn">.layers</span> <span class="kn">import</span> <span class="n">ArrayWithLayers</span>
<span class="kn">from</span> <span class="nn">.linear_algebra</span> <span class="kn">import</span> <span class="n">ArrayWithLinearAlgebra</span>
<span class="kn">from</span> <span class="nn">.losses</span> <span class="kn">import</span> <span class="n">ArrayWithLosses</span>
<span class="kn">from</span> <span class="nn">.manipulation</span> <span class="kn">import</span> <span class="n">ArrayWithManipulation</span>
<span class="kn">from</span> <span class="nn">.norms</span> <span class="kn">import</span> <span class="n">ArrayWithNorms</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">ArrayWithRandom</span>
<span class="kn">from</span> <span class="nn">.searching</span> <span class="kn">import</span> <span class="n">ArrayWithSearching</span>
<span class="kn">from</span> <span class="nn">.set</span> <span class="kn">import</span> <span class="n">ArrayWithSet</span>
<span class="kn">from</span> <span class="nn">.sorting</span> <span class="kn">import</span> <span class="n">ArrayWithSorting</span>
<span class="kn">from</span> <span class="nn">.statistical</span> <span class="kn">import</span> <span class="n">ArrayWithStatistical</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="kn">import</span> <span class="n">ArrayWithUtility</span>
<span class="kn">from</span> <span class="nn">.experimental</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The native array being wrapped in self.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Data type of the array elements&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Hardware device the array data resides on.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">mT</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpose of a matrix (or a stack of matrices).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        array whose last two dimensions (axes) are permuted in reverse order</span>
<span class="sd">        relative to original array (i.e., for an array instance having shape</span>
<span class="sd">        ``(..., M, N)``, the returned array must have shape ``(..., N, M)``).</span>
<span class="sd">        The returned array must have the same data type as the original array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Number of array dimensions (axes).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">))</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Array dimensions.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Number of elements in the array.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpose of the array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        two-dimensional array whose first and last dimensions (axes) are</span>
<span class="sd">        permuted in reverse order relative to original array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__torch_function__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__array_namespace__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_version</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.add. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.add also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 7, 9])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array reverse special method variant of ivy.add. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.add also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 6, 7])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.subtract. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.subtract also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise differences. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances only:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([-3, -3, -3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array reverse special method variant of ivy.subtract. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.subtract also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise differences. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([-3, -4, -5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__imatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__dlpack__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__dlpack_device__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Less than or equal to</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    an array containing the element-wise results. The returned array must have a</span>
<span class="sd">    data type of bool.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([6, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x &lt;= y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ False, True, True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__iand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ixor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.bitwise_right_shift. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.bitwise_right_shift</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``x1`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer data type. Each element must be greater than or equal</span>
<span class="sd">        to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances only:</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = a &gt;&gt; b</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array reverse special method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``x1`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer data type. Each element must be greater than or equal</span>
<span class="sd">        to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = 32</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = a &gt;&gt; b</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([32, 16,  8])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__irshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1">#ivy.array.creation</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<span class="c1"># Array API Standard #</span>
<span class="c1"># -------------------#</span>


<div class="viewcode-block" id="asarray"><a class="viewcode-back" href="../../../functional/ivy/creation/asarray/asarray_array.html#ivy.array.array_methods.asarray">[docs]</a><span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.asarray. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.asarray also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input data, in any form that can be converted to an array. This includes</span>
<span class="sd">        lists, lists of tuples, tuples, tuples of tuples, tuples of lists and</span>
<span class="sd">        ndarrays.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean, indicating whether or not to copy the input. Default: ``None``.</span>
<span class="sd">    dtype</span>
<span class="sd">        datatype, optional. Datatype is inferred from the input data.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array interpretation of ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="full_like"><a class="viewcode-back" href="../../../functional/ivy/creation/full_like/full_like_array.html#ivy.array.array_methods.full_like">[docs]</a><span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.full_like. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.full_like also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    fill_value</span>
<span class="sd">        Scalar fill value</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is `None`, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and where every element is equal</span>
<span class="sd">        to ``fill_value``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`int` datatype:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 0</span>
<span class="sd">    &gt;&gt;&gt; x.full_like(fill_value)</span>
<span class="sd">    ivy.array([0, 0, 0])</span>

<span class="sd">    With float datatype:</span>

<span class="sd">    &gt;&gt;&gt; fill_value = 0.000123</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array(ivy.ones(5))</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.000123, 0.000123, 0.000123, 0.000123, 0.000123])</span>

<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 1</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 1, 1, 1, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ones_like"><a class="viewcode-back" href="../../../functional/ivy/creation/ones_like/ones_like_array.html#ivy.array.array_methods.ones_like">[docs]</a><span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.ones_like. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.ones_like also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and filled with ones.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="zeros_like"><a class="viewcode-back" href="../../../functional/ivy/creation/zeros_like/zeros_like_array.html#ivy.array.array_methods.zeros_like">[docs]</a><span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.zeros_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.zeros_like also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and filled with ``zeros``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tril"><a class="viewcode-back" href="../../../functional/ivy/creation/tril/tril_array.html#ivy.array.array_methods.tril">[docs]</a><span class="k">def</span> <span class="nf">tril</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tril. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tril also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, N) and whose innermost two dimensions form</span>
<span class="sd">        MxN matrices.</span>
<span class="sd">    k</span>
<span class="sd">        diagonal above which to zero elements. If k = 0, the diagonal is the main</span>
<span class="sd">        diagonal. If k &lt; 0, the diagonal is below the main diagonal. If k &gt; 0, the</span>
<span class="sd">        diagonal is above the main diagonal. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the lower triangular part(s). The returned array must</span>
<span class="sd">        have the same shape and data type as ``self``. All elements above the</span>
<span class="sd">        specified diagonal k must be zeroed. The returned array should be allocated</span>
<span class="sd">        on the same device as ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="triu"><a class="viewcode-back" href="../../../functional/ivy/creation/triu/triu_array.html#ivy.array.array_methods.triu">[docs]</a><span class="k">def</span> <span class="nf">triu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.triu. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.triu also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, N) and whose innermost two dimensions form</span>
<span class="sd">        MxN matrices.    *,</span>
<span class="sd">    k</span>
<span class="sd">        diagonal below which to zero elements. If k = 0, the diagonal is the main</span>
<span class="sd">        diagonal. If k &lt; 0, the diagonal is below the main diagonal. If k &gt; 0, the</span>
<span class="sd">        diagonal is above the main diagonal. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the upper triangular part(s). The returned array must</span>
<span class="sd">        have the same shape and data type as ``self``. All elements below the</span>
<span class="sd">        specified diagonal k must be zeroed. The returned array should be allocated</span>
<span class="sd">        on the same device as ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="empty_like"><a class="viewcode-back" href="../../../functional/ivy/creation/empty_like/empty_like_array.html#ivy.array.array_methods.empty_like">[docs]</a><span class="k">def</span> <span class="nf">empty_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.empty_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.empty_like also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If dtype is None, the output array data type must be</span>
<span class="sd">        inferred from ``self``. Deafult: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is None, the output</span>
<span class="sd">        array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and containing uninitialized</span>
<span class="sd">        data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="meshgrid"><a class="viewcode-back" href="../../../functional/ivy/creation/meshgrid/meshgrid_array.html#ivy.array.array_methods.meshgrid">[docs]</a><span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">indexing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="n">list_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.meshgrid. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.meshgrid also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        one-dimensional input array.</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of one-dimensional arrays representing grid coordinates.</span>
<span class="sd">        Each array should have the same numeric data type.</span>
<span class="sd">    indexing</span>
<span class="sd">        Cartesian ``&#39;xy&#39;`` or matrix ``&#39;ij&#39;`` indexing of output. If provided zero</span>
<span class="sd">        or one one-dimensional vector(s) (i.e., the zero- and one-dimensional cases,</span>
<span class="sd">        respectively), the ``indexing`` keyword has no effect and should be ignored.</span>
<span class="sd">        Default: ``&#39;xy&#39;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        list of N arrays, where ``N`` is the number of provided one-dimensional</span>
<span class="sd">        input arrays. Each returned array must have rank ``N``. For ``N``</span>
<span class="sd">        one-dimensional arrays having lengths ``Ni = len(xi)``.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">list_arrays</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="n">indexing</span><span class="p">)</span></div>

<div class="viewcode-block" id="from_dlpack"><a class="viewcode-back" href="../../../functional/ivy/creation/from_dlpack/from_dlpack_array.html#ivy.array.array_methods.from_dlpack">[docs]</a><span class="k">def</span> <span class="nf">from_dlpack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.from_dlpack. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.from_dlpack also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the data in ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="copy_array"><a class="viewcode-back" href="../../../functional/ivy/creation/copy_array/copy_array_array.html#ivy.array.array_methods.copy_array">[docs]</a><span class="k">def</span> <span class="nf">copy_array</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.copy_array. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.copy_array also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a copy of the input array ``x``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="native_array"><a class="viewcode-back" href="../../../functional/ivy/creation/native_array/native_array_array.html#ivy.array.array_methods.native_array">[docs]</a><span class="k">def</span> <span class="nf">native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.native_array. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.native_array also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    dtype</span>
<span class="sd">        datatype, optional. Datatype is inferred from the input data.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A native array interpretation of ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">native_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span></div>

<div class="viewcode-block" id="one_hot"><a class="viewcode-back" href="../../../functional/ivy/creation/one_hot/one_hot_array.html#ivy.array.array_methods.one_hot">[docs]</a><span class="k">def</span> <span class="nf">one_hot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">on_value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">off_value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.one_hot. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.one_hot also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing the indices for which the ones should be scattered</span>
<span class="sd">    depth</span>
<span class="sd">        Scalar defining the depth of the one-hot dimension.</span>
<span class="sd">    on_value</span>
<span class="sd">        Value to fill in output when ``indices[j] == i``. Default 1.</span>
<span class="sd">    off_value</span>
<span class="sd">        Value to fill in output when ``indices[j] != i``. Default 0.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis to scatter on. The default is ``-1`` which is the last axis.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type of the output array. If None, the data type of the on_value is</span>
<span class="sd">        used, or if that is None, the data type of the off_value is used. Default</span>
<span class="sd">        float32.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        Same as x if None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Tensor of zeros with the same shape and type as a, unless dtype provided</span>
<span class="sd">        which overrides.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.data_type</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="n">Finfo</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">Iinfo</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="astype"><a class="viewcode-back" href="../../../functional/ivy/data_type/astype/astype_array.html#ivy.array.array_methods.astype">[docs]</a><span class="k">def</span> <span class="nf">astype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Copies an array to a specified data type irrespective of</span>
<span class="sd">    :ref:`type-promotion` rules.</span>

<span class="sd">    .. note::</span>
<span class="sd">    Casting floating-point ``NaN`` and ``infinity`` values to integral data types</span>
<span class="sd">    is not specified and is implementation-dependent.</span>

<span class="sd">    .. note::</span>
<span class="sd">    When casting a boolean input array to a numeric data type, a value of ``True``</span>
<span class="sd">    must cast to a numeric value equal to ``1``, and a value of ``False`` must cast</span>
<span class="sd">    to a numeric value equal to ``0``.</span>

<span class="sd">    When casting a numeric input array to ``bool``, a value of ``0`` must cast to</span>
<span class="sd">    ``False``, and a non-zero value must cast to ``True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array to cast.</span>
<span class="sd">    dtype</span>
<span class="sd">        desired data type.</span>
<span class="sd">    copy</span>
<span class="sd">        specifies whether to copy an array when the specified ``dtype`` matches</span>
<span class="sd">        the data type of the input array ``x``. If ``True``, a newly allocated</span>
<span class="sd">        array must always be returned. If ``False`` and the specified ``dtype``</span>
<span class="sd">        matches the data type of the input array, the input array must be returned;</span>
<span class="sd">        otherwise, a newly allocated must be returned. Default: ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the specified data type. The returned array must have</span>
<span class="sd">        the same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1, -2], [0, 2]])</span>
<span class="sd">    &gt;&gt;&gt; print(x.astype(ivy.float64))</span>
<span class="sd">    ivy.array([[-1., -2.],  [0.,  2.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="broadcast_arrays"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_arrays/broadcast_arrays_array.html#ivy.array.array_methods.broadcast_arrays">[docs]</a><span class="k">def</span> <span class="nf">broadcast_arrays</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.broadcast_arrays`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.broadcast_arrays`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        An input array to be broadcasted against other input arrays.</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of arrays to-be broadcasted.</span>
<span class="sd">        Each array must have the same shape.</span>
<span class="sd">        Each array must have the same dtype as its</span>
<span class="sd">        corresponding input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list containing broadcasted arrays of type `ivy.Array`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0.2, 0.])</span>
<span class="sd">    &gt;&gt;&gt; x3 = ivy.zeros(2)</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2, x3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([1, 2]), ivy.array([0.2, 0. ]), ivy.array([0., 0.])]</span>

<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([-1., 3.4])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.4, 5.1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([-1., 3.4]), ivy.array([2.4, 5.1])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span></div>

<div class="viewcode-block" id="broadcast_to"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_to/broadcast_to_array.html#ivy.array.array_methods.broadcast_to">[docs]</a><span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.broadcast_to`.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for `ivy.broadcast_to` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to be broadcasted.</span>
<span class="sd">    shape</span>
<span class="sd">        desired shape to be broadcasted to.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array to store the broadcasted array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns the broadcasted array of shape &#39;shape&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.broadcast_to((3,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1, 2, 3],</span>
<span class="sd">               [1, 2, 3],</span>
<span class="sd">               [1, 2, 3]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="can_cast"><a class="viewcode-back" href="../../../functional/ivy/data_type/can_cast/can_cast_array.html#ivy.array.array_methods.can_cast">[docs]</a><span class="k">def</span> <span class="nf">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.can_cast`. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for `ivy.can_cast` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to cast.</span>
<span class="sd">    to</span>
<span class="sd">        desired data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        ``True`` if the cast can occur according to :ref:`type-promotion` rules;</span>
<span class="sd">        otherwise, ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; print(x.dtype)</span>
<span class="sd">    float32</span>

<span class="sd">    &gt;&gt;&gt; print(x.can_cast(ivy.float64))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">to</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.dtype()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">as_native</span><span class="p">)</span>

<div class="viewcode-block" id="finfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/finfo/finfo_array.html#ivy.array.array_methods.finfo">[docs]</a><span class="k">def</span> <span class="nf">finfo</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Finfo</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="iinfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/iinfo/iinfo_array.html#ivy.array.array_methods.iinfo">[docs]</a><span class="k">def</span> <span class="nf">iinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iinfo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-119,122,14], dtype=ivy.int8))</span>
<span class="sd">    &gt;&gt;&gt; x.iinfo()</span>
<span class="sd">    iinfo(min=-128, max=127, dtype=int8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_bool_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_bool_dtype/is_bool_dtype_array.html#ivy.array.array_methods.is_bool_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_bool_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_float_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_float_dtype/is_float_dtype_array.html#ivy.array.array_methods.is_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.is_float_dtype`. This method simply</span>
<span class="sd">    checks to see if the array is of type `float`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to check for float dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean value of whether the array is of type `float`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3], dtype=ivy.int8)</span>
<span class="sd">    &gt;&gt;&gt; x.is_float_dtype()</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_int_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_int_dtype/is_int_dtype_array.html#ivy.array.array_methods.is_int_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_int_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_int_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_uint_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_uint_dtype/is_uint_dtype_array.html#ivy.array.array_methods.is_uint_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_uint_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_uint_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="result_type"><a class="viewcode-back" href="../../../functional/ivy/data_type/result_type/result_type_array.html#ivy.array.array_methods.result_type">[docs]</a><span class="k">def</span> <span class="nf">result_type</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.result_type`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.result_type` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to cast.</span>
<span class="sd">    arrays_and_dtypes</span>
<span class="sd">        an arbitrary number of input arrays and/or dtypes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the dtype resulting from an operation involving the input arrays and dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; print(x.dtype)</span>
<span class="sd">    int32</span>

<span class="sd">    &gt;&gt;&gt; x.result_type(ivy.float64)</span>
<span class="sd">    &lt;dtype:&#39;float64&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">)</span></div>

<span class="c1">#ivy.array.device</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">ivy</span>


<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<div class="viewcode-block" id="dev"><a class="viewcode-back" href="../../../functional/ivy/device/dev/dev_array.html#ivy.array.array_methods.dev">[docs]</a><span class="k">def</span> <span class="nf">dev</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.dev. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.dev also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2, 5, 4, 1], [3, 1, 5, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.dev(as_native=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    cpu</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_native</span><span class="o">=</span><span class="n">as_native</span><span class="p">)</span></div>

<div class="viewcode-block" id="to_device"><a class="viewcode-back" href="../../../functional/ivy/device/to_device/to_device_array.html#ivy.array.array_methods.to_device">[docs]</a><span class="k">def</span> <span class="nf">to_device</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_device. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_device also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.elementwise</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<span class="c1"># noinspection PyUnresolvedReferences</span>
<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../functional/ivy/elementwise/abs/abs_array.html#ivy.array.array_methods.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.abs. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.abs also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the absolute value of each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2.6, -6.6, 1.6, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.abs()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 2.6, 6.6, 1.6, 0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="acosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acosh/acosh_array.html#ivy.array.array_methods.acosh">[docs]</a><span class="k">def</span> <span class="nf">acosh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.acosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.acosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent the area of a hyperbolic sector.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse hyperbolic cosine</span>
<span class="sd">        of each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2., 10.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.acosh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.32, 2.99, 0.  ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="acos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acos/acos_array.html#ivy.array.array_methods.acos">[docs]</a><span class="k">def</span> <span class="nf">acos</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.acos. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.acos also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse cosine of each element in ``self``.</span>
<span class="sd">        The  returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0.0, -0.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.acos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.  , 1.57, 2.69])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../functional/ivy/elementwise/add/add_array.html#ivy.array.array_methods.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.add. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.add also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    alpha</span>
<span class="sd">        optional scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.add(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 7, 9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.add(y, alpha=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([9, 12, 15])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="asin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asin/asin_array.html#ivy.array.array_methods.asin">[docs]</a><span class="k">def</span> <span class="nf">asin</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.asin. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.asin also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse sine of each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 1., 4., 0.8])</span>
<span class="sd">    &gt;&gt;&gt; y = x.asin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1.57, 1.57, nan, 0.927])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-3., -0.9, 1.5, 2.8])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; x.asin(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([nan, -1.12, nan, nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="asinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asinh/asinh_array.html#ivy.array.array_methods.asinh">[docs]</a><span class="k">def</span> <span class="nf">asinh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.asinh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.asinh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent the area of a hyperbolic sector.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse hyperbolic sine of each element in ``self``.</span>
<span class="sd">        The returned array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 0., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.asinh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0.881,  0.   ,  1.82 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="atan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan/atan_array.html#ivy.array.array_methods.atan">[docs]</a><span class="k">def</span> <span class="nf">atan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atan. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atan also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse tangent of each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0.5, -0.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.atan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.785,  0.464, -0.464])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="atan2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan2/atan2_array.html#ivy.array.array_methods.atan2">[docs]</a><span class="k">def</span> <span class="nf">atan2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atan2. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atan2 also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array corresponding to the y-coordinates.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array corresponding to the x-coordinates.</span>
<span class="sd">        Must be compatible with ``self``(see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse tangent of the quotient ``self/x2``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0.5, 0.0, -0.5, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1.0, 2.0, -1.5, 0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; z = x.atan2(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 0.785,  0.245,  3.14 , -1.57 ,  0.   ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="atanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atanh/atanh_array.html#ivy.array.array_methods.atanh">[docs]</a><span class="k">def</span> <span class="nf">atanh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atanh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atanh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent the area of a hyperbolic sector.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse hyperbolic tangent of each element</span>
<span class="sd">        in ``self``. The returned array must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.0, 0.5, -0.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.atanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.   ,  0.549, -1.47 ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_and/bitwise_and_array.html#ivy.array.array_methods.bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">bitwise_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([True, False])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([True, True])</span>
<span class="sd">    &gt;&gt;&gt; x.bitwise_and(y, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ True, False])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[7],[8],[9]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.native_array([[10],[11],[12]])</span>
<span class="sd">    &gt;&gt;&gt; z = x.bitwise_and(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[2],[8],[8]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_left_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_left_shift/bitwise_left_shift_array.html#ivy.array.array_methods.bitwise_left_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_left_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_left_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_left_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_invert"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_invert/bitwise_invert_array.html#ivy.array.array_methods.bitwise_invert">[docs]</a><span class="k">def</span> <span class="nf">bitwise_invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_invert.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.bitiwse_invert also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have an integer or boolean data type.</span>

<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_or/bitwise_or_array.html#ivy.array.array_methods.bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">bitwise_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_or. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.bitwise_or also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>

<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.bitwise_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 7, 7])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_right_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_right_shift/bitwise_right_shift_array.html#ivy.array.array_methods.bitwise_right_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_right_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[2, 3, 4], [5, 10, 64]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = a.bitwise_right_shift(b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 2,  1,  1],</span>
<span class="sd">                [ 5,  5, 16]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_xor/bitwise_xor_array.html#ivy.array.array_methods.bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">bitwise_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.bitwise_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[89, 51, 32], [14, 18, 19]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([[[19, 26, 27], [22, 23, 20]]])</span>
<span class="sd">    &gt;&gt;&gt; y = a.bitwise_xor(b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[[74,41,59],[24,5,7]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ceil"><a class="viewcode-back" href="../../../functional/ivy/elementwise/ceil/ceil_array.html#ivy.array.array_methods.ceil">[docs]</a><span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.ceil.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ceil also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.5, -2.5, 1.5, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.ceil()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 6., -2.,  2.,  0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cos/cos_array.html#ivy.array.array_methods.cos">[docs]</a><span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cos. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cos also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are each expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the cosine of each element in ``self``. The returned</span>
<span class="sd">        array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 0., 2.,])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.54, 1., -0.416])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-3., 0., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; ivy.cos(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0.99,  1.  , -0.99])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1.,], [2., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1., 0.540], [-0.416, -0.990]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cosh/cosh_array.html#ivy.array.array_methods.cosh">[docs]</a><span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cosh. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.cosh also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the hyperbolic cosine of each element in ``self``.</span>
<span class="sd">        The returned array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; print(x.cosh())</span>
<span class="sd">        ivy.array([1.54, 3.76, 10.1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.23, 3., -1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; print(x.cosh(out=y))</span>
<span class="sd">        ivy.array([1.03, 10.1, 1.81])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/divide/divide_array.html#ivy.array.array_methods.divide">[docs]</a><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.divide. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.divide also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2., 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 3.5, 4.5])</span>

<span class="sd">    With mixed :class:`ivy.Array` and `ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2., 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 3.5, 4.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/equal/equal_array.html#ivy.array.array_methods.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, True, True])</span>

<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.5, 2.9, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False,  True])</span>

<span class="sd">    With mixed :class:`ivy.Array` and `float` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = 7.3</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, True, False])</span>

<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 1., 0.9])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="exp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/exp/exp_array.html#ivy.array.array_methods.exp">[docs]</a><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.exp. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.exp also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated exponential function result for</span>
<span class="sd">        each element in ``self``. The returned array must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="expm1"><a class="viewcode-back" href="../../../functional/ivy/elementwise/expm1/expm1_array.html#ivy.array.array_methods.expm1">[docs]</a><span class="k">def</span> <span class="nf">expm1</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.expm1. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.expm1 also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.5, -2.5, 1.5, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.expm1()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([244.   ,  -0.918,   3.48 ,   0.   ])</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5., 0.])</span>
<span class="sd">    &gt;&gt;&gt; _ = x.expm1(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([147.,   0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="floor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor/floor_array.html#ivy.array.array_methods.floor">[docs]</a><span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.floor. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.floor also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.5, -2.5, 1.5, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.floor()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 5., -3.,  1.,  0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="floor_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor_divide/floor_divide_array.html#ivy.array.array_methods.floor_divide">[docs]</a><span class="k">def</span> <span class="nf">floor_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.floor_divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.floor_divide</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([13., 7., 8.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 7.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([4., 3., 1.])</span>

<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([13., 7., 8.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([3., 2., 7.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([4., 3., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater/greater_array.html#ivy.array.array_methods.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.greater.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must</span>
<span class="sd">        have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.greater(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False,  True,  True])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="greater_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater_equal/greater_equal_array.html#ivy.array.array_methods.greater_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="isfinite"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isfinite/isfinite_array.html#ivy.array.array_methods.isfinite">[docs]</a><span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isfinite.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.isfinite also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is finite and ``False`` otherwise.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, ivy.nan, -ivy.inf, float(&#39;inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.isfinite()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ True, False, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="isinf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isinf/isinf_array.html#ivy.array.array_methods.isinf">[docs]</a><span class="k">def</span> <span class="nf">isinf</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isinf. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isinf also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is either positive or negative infinity and ``False``</span>
<span class="sd">        otherwise. The returned array must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="isnan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isnan/isnan_array.html#ivy.array.array_methods.isnan">[docs]</a><span class="k">def</span> <span class="nf">isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isnan. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isnan also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is ``NaN`` and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="less"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less/less_array.html#ivy.array.array_methods.less">[docs]</a><span class="k">def</span> <span class="nf">less</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.less. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.less also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ True, False, False])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="less_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less_equal/less_equal_array.html#ivy.array.array_methods.less_equal">[docs]</a><span class="k">def</span> <span class="nf">less_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.less_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.less_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:&#39;ivy.Array&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, True, False])</span>

<span class="sd">    With mixed :code:&#39;ivy.Array&#39; and :code:&#39;ivy.NativeArray&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 3.3, 9.24])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.5, 1.1, 9.24])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False, True])</span>

<span class="sd">    With mixed :code:&#39;ivy.Container&#39; and :code:&#39;ivy.Array&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 1., 0.8])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([2., 1., 0.7]), b=ivy.array([3., 0.6, 1.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False]),</span>
<span class="sd">        b: ivy.array([True, False, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log/log_array.html#ivy.array.array_methods.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.log also applies to this method</span>
<span class="sd">    with minimal changes.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([4.0, 1, -0.0, -5.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.39, 0., -inf, nan])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;nan&#39;), -5.0, -0.0, 1.0, 5.0, float(&#39;+inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([nan, nan, -inf, 0., 1.61, inf])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[float(&#39;nan&#39;), 1, 5.0, float(&#39;+inf&#39;)],</span>
<span class="sd">    ...                [+0, -1.0, -5, float(&#39;-inf&#39;)]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[nan, 0., 1.61, inf],</span>
<span class="sd">               [-inf, nan, nan, nan]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log1p"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log1p/log1p_array.html#ivy.array.array_methods.log1p">[docs]</a><span class="k">def</span> <span class="nf">log1p</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log1p.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.log1p also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 2 ,3 ])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log1p()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.693, 1.1  , 1.39 ])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.1 , .001 ])</span>
<span class="sd">    &gt;&gt;&gt; x.log1p( out = x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([0.0953, 0.001 ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log2/log2_array.html#ivy.array.array_methods.log2">[docs]</a><span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log2 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated base ``2`` logarithm for each element</span>
<span class="sd">        in ``self``. The returned array must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log10"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log10/log10_array.html#ivy.array.array_methods.log10">[docs]</a><span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log10. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.log10 also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated base ``10`` logarithm for each element</span>
<span class="sd">        in ``self``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([4.0, 1, -0.0, -5.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.602, 0., -inf, nan])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;nan&#39;), -5.0, -0.0, 1.0, 5.0, float(&#39;+inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([nan, nan, -inf, 0., 0.699, inf])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[float(&#39;nan&#39;), 1, 5.0, float(&#39;+inf&#39;)],</span>
<span class="sd">    ...                [+0, -1.0, -5, float(&#39;-inf&#39;)]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[nan, 0., 0.699, inf],</span>
<span class="sd">               [-inf, nan, nan, nan]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logaddexp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logaddexp/logaddexp_array.html#ivy.array.array_methods.logaddexp">[docs]</a><span class="k">def</span> <span class="nf">logaddexp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logaddexp.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logaddexp also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a real-valued floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logaddexp(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 3.31,  5.05, 15.  ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_and/logical_and_array.html#ivy.array.array_methods.logical_and">[docs]</a><span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using &#39;ivy.Array&#39; instance:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([True, False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([True, True, False, False])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_and(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([True, False, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_not"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_not/logical_not_array.html#ivy.array.array_methods.logical_not">[docs]</a><span class="k">def</span> <span class="nf">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_not.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.logical_not also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_or/logical_or_array.html#ivy.array.array_methods.logical_or">[docs]</a><span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_or.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_or also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    This function conforms to the `Array API Standard</span>
<span class="sd">    &lt;https://data-apis.org/array-api/latest/&gt;`_. This docstring is an extension of the</span>
<span class="sd">    `docstring &lt;https://data-apis.org/array-api/latest/API_specification/generated/signatures.elementwise_functions.logical_or.html&gt;`_ </span>
<span class="sd">    in the standard.</span>

<span class="sd">    Both the description and the type hints above assumes an array input for simplicity,</span>
<span class="sd">    but this function is *nestable*, and therefore also accepts :class:`ivy.Container`</span>
<span class="sd">    instances in place of any of the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([False, 3, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([2, True, False])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ True,  True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_xor/logical_xor_array.html#ivy.array.array_methods.logical_xor">[docs]</a><span class="k">def</span> <span class="nf">logical_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.logical_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([True, False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([True, True, False, False])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_xor(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([False,  True,  True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../../functional/ivy/elementwise/multiply/multiply_array.html#ivy.array.array_methods.multiply">[docs]</a><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.multiply.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.multiply</span>
<span class="sd">     also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self (Array)</span>
<span class="sd">         first input array. Should have a real-valued data type.</span>
<span class="sd">         Note : &quot;self.data&quot; replaces the first array arguement in the function.</span>
<span class="sd">    x2 (Union[Array, NativeArray])</span>
<span class="sd">        second input array.</span>
<span class="sd">        Must be compatible with the first input array.</span>
<span class="sd">        The condition for compatibility is Broadcasting :  ``x1.shape!=x2.shape`` .</span>
<span class="sd">        The arrays must be boradcastble to get a common shape for the output.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape thatthe inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products. The returned array</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With ivy.Array instance method:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 5., 7.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([4., 6., 8.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.multiply(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([12., 30., 56.])</span>

<span class="sd">    With mix of ivy.Array and ivy.NativeArray instance method:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([8., 6., 7.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.multiply(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 8., 12., 21.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="maximum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/maximum/maximum_array.html#ivy.array.array_methods.maximum">[docs]</a><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.maximum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.maximum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to maximum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing maximum values, must be broadcastable to x1.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the maximum. If ``False``, the</span>
<span class="sd">        maximum is calculated using the ``(x + y + |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not be lower than the x2</span>
<span class="sd">        values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="minimum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/minimum/minimum_array.html#ivy.array.array_methods.minimum">[docs]</a><span class="k">def</span> <span class="nf">minimum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to minimum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing minimum values, must be broadcastable to x1.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the minimum. If ``False``, the</span>
<span class="sd">        minimum is calculated using the ``(x + y - |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not exceed the x2 values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="negative"><a class="viewcode-back" href="../../../functional/ivy/elementwise/negative/negative_array.html#ivy.array.array_methods.negative">[docs]</a><span class="k">def</span> <span class="nf">negative</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.negative.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.negative also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="not_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/not_equal/not_equal_array.html#ivy.array.array_methods.not_equal">[docs]</a><span class="k">def</span> <span class="nf">not_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.not_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.not_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned</span>
<span class="sd">        array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False, False])</span>

<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.5, 2.9, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, True,  False])</span>

<span class="sd">    With mixed :class:`ivy.Array` and `float` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = 7.3</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False, True])</span>

<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 1., 0.9])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="positive"><a class="viewcode-back" href="../../../functional/ivy/elementwise/positive/positive_array.html#ivy.array.array_methods.positive">[docs]</a><span class="k">def</span> <span class="nf">positive</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.positive.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.positive also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">     &gt;&gt;&gt; x = ivy.array([2, 3 ,5, 7])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.positive(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2, 3, 5, 7])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, -1, -0.5, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.positive(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., -1., -0.5,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3],</span>
<span class="sd">    ...                [-4.4, -5.5, -6.6]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.positive(x,out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[ 1.1,  2.2,  3.3],</span>
<span class="sd">    [-4.4, -5.5, -6.6]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="pow"><a class="viewcode-back" href="../../../functional/ivy/elementwise/pow/pow_array.html#ivy.array.array_methods.pow">[docs]</a><span class="k">def</span> <span class="nf">pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.pow. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.pow also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array whose elements correspond to the exponentiation base.</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array whose elements correspond to the exponentiation</span>
<span class="sd">        exponent. Must be compatible with ``self`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="remainder"><a class="viewcode-back" href="../../../functional/ivy/elementwise/remainder/remainder_array.html#ivy.array.array_methods.remainder">[docs]</a><span class="k">def</span> <span class="nf">remainder</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">modulus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.remainder.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.remainder also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    modulus</span>
<span class="sd">        whether to compute the modulus instead of the remainder.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        Each element-wise result must have the same sign as the respective</span>
<span class="sd">        element ``x2_i``. The returned array must have a data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2., 1., 3.])</span>

<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([11., 4., 18.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2., 5., 8.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 4., 2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="round"><a class="viewcode-back" href="../../../functional/ivy/elementwise/round/round_array.html#ivy.array.array_methods.round">[docs]</a><span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.round. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.round also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([6.3, -8.1, 0.5, -4.2, 6.8])</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 6., -8.,  0., -4.,  7.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-94.2, 256.0, 0.0001, -5.5, 36.6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-94., 256., 0., -6., 37.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.23, 3., -1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; x.round(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.,  3., -1.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[ -1., -67.,  0.,  15.5,  1.], [3, -45, 24.7, -678.5, 32.8]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-1., -67., 0., 16., 1.],</span>
<span class="sd">    [3., -45., 25., -678., 33.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sign"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sign/sign_array.html#ivy.array.array_methods.sign">[docs]</a><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sign. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sign also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.7, -7.1, 0, -0, 6.8])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 1., -1.,  0.,  0.,  1.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-94.2, 256.0, 0.0001, -0.0001, 36.6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1.,  1.,  1., -1.,  1.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[ -1., -67.,  0.,  15.5,  1.], [3, -45, 24.7, -678.5, 32.8]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-1., -1.,  0.,  1.,  1.],</span>
<span class="sd">    [ 1., -1.,  1., -1.,  1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sin/sin_array.html#ivy.array.array_methods.sin">[docs]</a><span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sin. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sin also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are each expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the sine of each element in ``self``. The returned</span>
<span class="sd">        array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0.841, 0.909, 0.141])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sinh/sinh_array.html#ivy.array.array_methods.sinh">[docs]</a><span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sinh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sinh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the hyperbolic sine of each element in ``self``. The</span>
<span class="sd">        returned array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; print(x.sinh())</span>
<span class="sd">        ivy.array([1.18, 3.63, 10.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.23, 3., -1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; print(x.sinh(out=y))</span>
<span class="sd">        ivy.array([0.232, 10., -1.51])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../functional/ivy/elementwise/square/square_array.html#ivy.array.array_methods.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.square.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.square also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the square of each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sqrt/sqrt_array.html#ivy.array.array_methods.sqrt">[docs]</a><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sqrt. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sqrt also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the square root of each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../functional/ivy/elementwise/subtract/subtract_array.html#ivy.array.array_methods.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.subtract.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.subtract also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    alpha</span>
<span class="sd">        optional scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise differences. The returned array</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.subtract(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([4, 0, -3])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([5., 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.subtract(y, alpha=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([-3., -5., -9.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tan/tan_array.html#ivy.array.array_methods.tan">[docs]</a><span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tan. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tan also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the tangent of each element in ``self``.</span>
<span class="sd">        The return must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.tan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 1.56, -2.19])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tanh/tanh_array.html#ivy.array.array_methods.tanh">[docs]</a><span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tanh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tanh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the hyperbolic tangent of each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.tanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0.762, 0.964])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="trunc"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc/trunc_array.html#ivy.array.array_methods.trunc">[docs]</a><span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.trunc. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.trunc also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1, 0.54, 3.67, -0.025])</span>
<span class="sd">    &gt;&gt;&gt; y = x.trunc()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1.,  0.,  3., -0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="erf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/erf/erf_array.html#ivy.array.array_methods.erf">[docs]</a><span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.erf. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.erf also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to compute exponential for.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the Gauss error of ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="reciprocal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/reciprocal/reciprocal_array.html#ivy.array.array_methods.reciprocal">[docs]</a><span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.reciprocal.This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.reciprocal also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to compute the element-wise reciprocal for.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise reciprocal of ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="deg2rad"><a class="viewcode-back" href="../../../functional/ivy/elementwise/deg2rad/deg2rad_array.html#ivy.array.array_methods.deg2rad">[docs]</a><span class="k">def</span> <span class="nf">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.deg2rad.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.deg2rad also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. to be converted from degrees to radians.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise conversion from degrees to radians.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.array([90,180,270,360])</span>
<span class="sd">    &gt;&gt;&gt; y=x.deg2rad()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.57, 3.14, 4.71, 6.28])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="rad2deg"><a class="viewcode-back" href="../../../functional/ivy/elementwise/rad2deg/rad2deg_array.html#ivy.array.array_methods.rad2deg">[docs]</a><span class="k">def</span> <span class="nf">rad2deg</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.rad2deg.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.rad2deg also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. to be converted from degrees to radians.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise conversion from radians to degrees.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.array([1,5,8,10])</span>
<span class="sd">    &gt;&gt;&gt; y=x.rad2deg()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 57.3, 286. , 458. , 573. ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="trunc_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc_divide/trunc_divide_array.html#ivy.array.array_methods.trunc_divide">[docs]</a><span class="k">def</span> <span class="nf">trunc_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.trunc_divide. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.trunc_divide also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2., -2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.trunc_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 1., -3.,  4.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="isreal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isreal/isreal_array.html#ivy.array.array_methods.isreal">[docs]</a><span class="k">def</span> <span class="nf">isreal</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isreal. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isreal also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is real number and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1j, 2+5j, 3.7-6j])</span>
<span class="sd">    &gt;&gt;&gt; x.isreal()</span>
<span class="sd">    ivy.array([False, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.general</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="is_native_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_native_array/is_native_array_array.html#ivy.array.array_methods.is_native_array">[docs]</a><span class="k">def</span> <span class="nf">is_native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_native_array. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.is_native_array</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is a native array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_ivy_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_array/is_ivy_array_array.html#ivy.array.array_methods.is_ivy_array">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_array</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_ivy_array. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.is_ivy_array also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_array/is_array_array.html#ivy.array.array_methods.is_array">[docs]</a><span class="k">def</span> <span class="nf">is_array</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_array. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.is_array also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_ivy_container"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_container/is_ivy_container_array.html#ivy.array.array_methods.is_ivy_container">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_container</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_ivy_container. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.is_ivy_container also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_container</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_equal"><a class="viewcode-back" href="../../../functional/ivy/general/all_equal/all_equal_array.html#ivy.array.array_methods.all_equal">[docs]</a><span class="k">def</span> <span class="nf">all_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="n">x2</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">equality_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.all_equal. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all_equal also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    x2</span>
<span class="sd">        input iterable to compare to ``self``</span>
<span class="sd">    equality_matrix</span>
<span class="sd">        Whether to return a matrix of equalities comparing each input with every</span>
<span class="sd">        other. Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the inputs are equal, or matrix array of booleans if</span>
<span class="sd">        equality_matrix=True is set.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">all_equal</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">equality_matrix</span><span class="o">=</span><span class="n">equality_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="has_nans"><a class="viewcode-back" href="../../../functional/ivy/general/has_nans/has_nans_array.html#ivy.array.array_methods.has_nans">[docs]</a><span class="k">def</span> <span class="nf">has_nans</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">include_infs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.has_nans. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.has_nans also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include ``+infinity`` and ``-infinity`` in the check.</span>
<span class="sd">        Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the array contains nans.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.has_nans()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gather"><a class="viewcode-back" href="../../../functional/ivy/general/gather/gather_array.html#ivy.array.array_methods.gather">[docs]</a><span class="k">def</span> <span class="nf">gather</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gather. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gather also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        The array which indicates the indices that will be gathered along</span>
<span class="sd">        the specified axis.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis from which the indices will be gathered. Default is ``-1``.</span>
<span class="sd">    batch_dims</span>
<span class="sd">        optional int, lets you gather different items from each element of a batch.</span>
<span class="sd">    out</span>
<span class="sd">        optional array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with the values gathered at the specified indices along</span>
<span class="sd">        the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; x.gather(y)</span>
<span class="sd">    ivy.array([0., 1.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="scatter_nd"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_nd/scatter_nd_array.html#ivy.array.array_methods.scatter_nd">[docs]</a><span class="k">def</span> <span class="nf">scatter_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scatter updates into an array according to indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array of indices</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the result. Default is ``None``, in which case tensor</span>
<span class="sd">        argument must be provided.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array of given shape, with the values scattered at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    scatter values into an array</span>

<span class="sd">    &gt;&gt;&gt; arr = ivy.array([1,2,3,4,5,6,7,8, 9, 10])</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.array([[4], [3], [1], [7]])</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.array([9, 10, 11, 12])</span>
<span class="sd">    &gt;&gt;&gt; scatter = indices.scatter_nd(updates, reduction=&#39;replace&#39;, out=arr)</span>
<span class="sd">    &gt;&gt;&gt; print(scatter)</span>
<span class="sd">    ivy.array([ 1, 11,  3, 10,  9,  6,  7, 12,  9, 10])</span>

<span class="sd">    scatter values into an empty array</span>

<span class="sd">    &gt;&gt;&gt; shape = ivy.array([2, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.array([[1,4], [0,3], [1,1], [0,2]])</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.array([25, 40, 21, 22])</span>
<span class="sd">    &gt;&gt;&gt; scatter = indices.scatter_nd(updates, shape=shape)</span>
<span class="sd">    &gt;&gt;&gt; print(scatter)</span>
<span class="sd">    ivy.array([[ 0,  0, 22, 40,  0],</span>
<span class="sd">                [ 0, 21,  0,  0, 25]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gather_nd"><a class="viewcode-back" href="../../../functional/ivy/general/gather_nd/gather_nd_array.html#ivy.array.array_methods.gather_nd">[docs]</a><span class="k">def</span> <span class="nf">gather_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gather_nd. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.gather_nd also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        Index array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array of given shape, with the values gathered at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1])</span>
<span class="sd">    &gt;&gt;&gt; z = x.gather_nd(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einops_rearrange"><a class="viewcode-back" href="../../../functional/ivy/general/einops_rearrange/einops_rearrange_array.html#ivy.array.array_methods.einops_rearrange">[docs]</a><span class="k">def</span> <span class="nf">einops_rearrange</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.einops_rearrange.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.einops_rearrange also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to be re-arranged.</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with einops.rearrange having been applied.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einops_reduce"><a class="viewcode-back" href="../../../functional/ivy/general/einops_reduce/einops_reduce_array.html#ivy.array.array_methods.einops_reduce">[docs]</a><span class="k">def</span> <span class="nf">einops_reduce</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.einops_reduce. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_reduce also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to be reduced.</span>
<span class="sd">    pattern</span>
<span class="sd">        Reduction pattern.</span>
<span class="sd">    reduction</span>
<span class="sd">        One of available reductions (&#39;min&#39;, &#39;max&#39;, &#39;sum&#39;, &#39;mean&#39;, &#39;prod&#39;), or</span>
<span class="sd">        callable.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with einops.reduce having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[5, 4],</span>
<span class="sd">    ...                 [11, 2]],</span>
<span class="sd">    ...                [[3, 5],</span>
<span class="sd">    ...                 [9, 7]]])</span>

<span class="sd">    &gt;&gt;&gt; y = x.einops_reduce(&#39;a b c -&gt; b c&#39;, &#39;max&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 5,  5],</span>
<span class="sd">               [11,  7]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[5, 4, 3],</span>
<span class="sd">    ...                 [11, 2, 9]],</span>
<span class="sd">    ...                [[3, 5, 7],</span>
<span class="sd">    ...                 [9, 7, 1]]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_reduce(&#39;a b c -&gt; a () c&#39;, &#39;min&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[[5, 2, 3]],</span>
<span class="sd">               [[3, 5, 1]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einops_repeat"><a class="viewcode-back" href="../../../functional/ivy/general/einops_repeat/einops_repeat_array.html#ivy.array.array_methods.einops_repeat">[docs]</a><span class="k">def</span> <span class="nf">einops_repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.einops_repeat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_repeat also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to be repeated.</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with einops.repeat having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5,4])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_repeat(&#39;a -&gt; a c&#39;, c=3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[5,5,5],[4,4,4]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[5,4],</span>
<span class="sd">    ...                [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_repeat(&#39;a b -&gt;  a b c&#39;, c=3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[5,5,5],[4,4,4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="to_numpy"><a class="viewcode-back" href="../../../functional/ivy/general/to_numpy/to_numpy_array.html#ivy.array.array_methods.to_numpy">[docs]</a><span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_numpy. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_numpy also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a numpy array copying all the element of the array ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_numpy()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [-1  0  1]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1, 0, 1],[-1, 0, 1], [1,0,-1]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_numpy()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [[-1  0  1]</span>
<span class="sd">    [-1  0  1]</span>
<span class="sd">    [ 1  0 -1]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>

<div class="viewcode-block" id="to_list"><a class="viewcode-back" href="../../../functional/ivy/general/to_list/to_list_array.html#ivy.array.array_methods.to_list">[docs]</a><span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_list. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_list also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list representation of the input array ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_list()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [0, 1, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="supports_inplace_updates"><a class="viewcode-back" href="../../../functional/ivy/general/supports_inplace_updates/supports_inplace_updates_array.html#ivy.array.array_methods.supports_inplace_updates">[docs]</a><span class="k">def</span> <span class="nf">supports_inplace_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.supports_inplace_updates. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.supports_inplace also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array whose elements&#39; data type is to be checked.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Bool value depends on whether the currently active backend</span>
<span class="sd">        framework supports in-place operations with argument&#39;s data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With `ivy.Array` input and backend set as &quot;tensorflow&quot;:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 4.2, 2.2])</span>
<span class="sd">    &gt;&gt;&gt; ret = x.supports_inplace_updates()</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">supports_inplace_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="inplace_decrement"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_decrement/inplace_decrement_array.html#ivy.array.array_methods.inplace_decrement">[docs]</a><span class="k">def</span> <span class="nf">inplace_decrement</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inplace_decrement. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.inplace_decrement also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array to be decremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of decrement.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place decrement.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance methods:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.7, 4.3, 2.5, 1.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_decrement(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([4.7, 3.3, 1.5, 0.9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4., 5., 6.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_decrement(2.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.5, 2.5, 3.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="stable_divide"><a class="viewcode-back" href="../../../functional/ivy/general/stable_divide/stable_divide_array.html#ivy.array.array_methods.stable_divide">[docs]</a><span class="k">def</span> <span class="nf">stable_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">min_denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stable_divide. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.stable_divide also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array, used as the numerator for division.</span>
<span class="sd">    denominator</span>
<span class="sd">        denominator for division.</span>
<span class="sd">    min_denominator</span>
<span class="sd">        the minimum denominator to use, use global ivy._MIN_DENOMINATOR by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a numpy array containing the elements of numerator divided by</span>
<span class="sd">        the corresponding element of denominator</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4., 5., 6.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.stable_divide(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2., 2.5, 3.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.stable_divide(4, min_denominator=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.8, 1. , 1.2])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([[4., 5., 6.], [7., 8., 9.]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.asarray([[1., 2., 3.], [2., 3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; z = x.stable_divide(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[4.  , 2.5 , 2.  ],</span>
<span class="sd">            [3.5 , 2.67, 2.25]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="clip_vector_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_vector_norm/clip_vector_norm_array.html#ivy.array.array_methods.clip_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.clip_vector_norm. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.clip_vector_norm also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        float, the maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        optional float, the p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_vector_norm(2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0.894, 1.79])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="array_equal"><a class="viewcode-back" href="../../../functional/ivy/general/array_equal/array_equal_array.html#ivy.array.array_methods.array_equal">[docs]</a><span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.array_equal. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.array_equal also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    x</span>
<span class="sd">        input array to compare to ``self``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the input arrays are equal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="assert_supports_inplace"><a class="viewcode-back" href="../../../functional/ivy/general/assert_supports_inplace/assert_supports_inplace_array.html#ivy.array.array_methods.assert_supports_inplace">[docs]</a><span class="k">def</span> <span class="nf">assert_supports_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.assert_supports_inplace. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.assert_supports_inplace</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        True if support, raises exception otherwise</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">assert_supports_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="to_scalar"><a class="viewcode-back" href="../../../functional/ivy/general/to_scalar/to_scalar_array.html#ivy.array.array_methods.to_scalar">[docs]</a><span class="k">def</span> <span class="nf">to_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_scalar. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_scalar also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a scalar copying the element of the array ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_scalar()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">to_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="fourier_encode"><a class="viewcode-back" href="../../../functional/ivy/general/fourier_encode/fourier_encode_array.html#ivy.array.array_methods.fourier_encode">[docs]</a><span class="k">def</span> <span class="nf">fourier_encode</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">concat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.fourier_encode. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fourier_encode also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to encode</span>
<span class="sd">    max_freq</span>
<span class="sd">        The maximum frequency of the encoding.</span>
<span class="sd">    num_bands</span>
<span class="sd">        The number of frequency bands for the encoding. Default is 4.</span>
<span class="sd">    linear</span>
<span class="sd">        Whether to space the frequency bands linearly as opposed to geometrically.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    concat</span>
<span class="sd">        Whether to concatenate the position, sin and cos values, or return</span>
<span class="sd">        seperately. Default is ``True``.</span>
<span class="sd">    flatten</span>
<span class="sd">        Whether to flatten the position dimension into the batch dimension.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with the final dimension expanded, and the encodings stored in</span>
<span class="sd">        this channel.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fourier_encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="p">,</span>
        <span class="n">num_bands</span><span class="o">=</span><span class="n">num_bands</span><span class="p">,</span>
        <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
        <span class="n">concat</span><span class="o">=</span><span class="n">concat</span><span class="p">,</span>
        <span class="n">flatten</span><span class="o">=</span><span class="n">flatten</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="value_is_nan"><a class="viewcode-back" href="../../../functional/ivy/general/value_is_nan/value_is_nan_array.html#ivy.array.array_methods.value_is_nan">[docs]</a><span class="k">def</span> <span class="nf">value_is_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">include_infs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.value_is_nan. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.value_is_nan also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the input value is a nan or not.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([92])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;nan&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan(include_infs=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">value_is_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_infs</span><span class="o">=</span><span class="n">include_infs</span><span class="p">)</span></div>

<div class="viewcode-block" id="exists"><a class="viewcode-back" href="../../../functional/ivy/general/exists/exists_array.html#ivy.array.array_methods.exists">[docs]</a><span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.exists. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.exists also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        True if x is not None, else False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="default"><a class="viewcode-back" href="../../../functional/ivy/general/default/default_array.html#ivy.array.array_methods.default">[docs]</a><span class="k">def</span> <span class="nf">default</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">default_val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">catch_exceptions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">rev</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">with_callable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.default. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.default also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    default_val</span>
<span class="sd">        The default value.</span>
<span class="sd">    catch_exceptions</span>
<span class="sd">        Whether to catch exceptions from callable x. Default is ``False``.</span>
<span class="sd">    rev</span>
<span class="sd">        Whether to reverse the input x and default_val. Default is ``False``.</span>
<span class="sd">    with_callable</span>
<span class="sd">        Whether either of the arguments might be callable functions.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        x if x exists (is not None), else default.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">default_val</span><span class="p">,</span>
        <span class="n">catch_exceptions</span><span class="o">=</span><span class="n">catch_exceptions</span><span class="p">,</span>
        <span class="n">rev</span><span class="o">=</span><span class="n">rev</span><span class="p">,</span>
        <span class="n">with_callable</span><span class="o">=</span><span class="n">with_callable</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="stable_pow"><a class="viewcode-back" href="../../../functional/ivy/general/stable_pow/stable_pow_array.html#ivy.array.array_methods.stable_pow">[docs]</a><span class="k">def</span> <span class="nf">stable_pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stable_pow. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.stable_pow also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array, used as the base.</span>
<span class="sd">    exponent</span>
<span class="sd">        The exponent number.</span>
<span class="sd">    min_base</span>
<span class="sd">        The minimum base to use, use global ivy._MIN_BASE by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new item following the numerically stable power.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="inplace_update"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_update/inplace_update_array.html#ivy.array.array_methods.inplace_update">[docs]</a><span class="k">def</span> <span class="nf">inplace_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">ensure_in_backend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inplace_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.inplace_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to update</span>
<span class="sd">    val</span>
<span class="sd">        The array to update the variable with.</span>
<span class="sd">    ensure_in_backend</span>
<span class="sd">        Whether or not to ensure that the `ivy.NativeArray` is also inplace updated.</span>
<span class="sd">        In cases where it should be, backends which do not natively support inplace</span>
<span class="sd">        updates will raise an exception.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following the in-place update.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="inplace_increment"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_increment/inplace_increment_array.html#ivy.array.array_methods.inplace_increment">[docs]</a><span class="k">def</span> <span class="nf">inplace_increment</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inplace_increment. This</span>
<span class="sd">    method wraps the function, and so the docstring for</span>
<span class="sd">    ivy.inplace_increment also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array to be incremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of increment.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place increment.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance methods:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.7, 4.3, 2.5, 1.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_increment(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6.7, 5.3, 3.5, 2.9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4., 5., 6.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_increment(2.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6.5, 7.5, 8.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="clip_matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_matrix_norm/clip_matrix_norm_array.html#ivy.array.array_methods.clip_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.clip_matrix_norm. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.clip_matrix_norm also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        The maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        The p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the matrix norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_matrix_norm(2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0.   , 0.894, 1.79 ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="scatter_flat"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_flat/scatter_flat_array.html#ivy.array.array_methods.scatter_flat">[docs]</a><span class="k">def</span> <span class="nf">scatter_flat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.scatter_flat. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.scatter_flat also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing the indices where the new values will occupy</span>
<span class="sd">    updates</span>
<span class="sd">        Values for the new array to hold.</span>
<span class="sd">    size</span>
<span class="sd">        The size of the result.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39; or</span>
<span class="sd">        &#39;replace&#39;</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array of given shape, with the values scattered at the indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="get_num_dims"><a class="viewcode-back" href="../../../functional/ivy/general/get_num_dims/get_num_dims_array.html#ivy.array.array_methods.get_num_dims">[docs]</a><span class="k">def</span> <span class="nf">get_num_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">as_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.shape. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.shape also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to infer the number of dimensions  for</span>
<span class="sd">    as_array</span>
<span class="sd">        Whether to return the shape as a array, default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Shape of the array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.,1.,1.],[1.,0.,0.],[8.,2.,3.]])</span>
<span class="sd">    &gt;&gt;&gt; b = x.get_num_dims()</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    2</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0, 0, 0], [0, 0, 0], [0, 0, 0]],\</span>
<span class="sd">                        [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\</span>
<span class="sd">                        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]])</span>
<span class="sd">    &gt;&gt;&gt; b = x.get_num_dims(as_array=False)</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    3</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; b = x.get_num_dims(as_array=True)</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    ivy.array(3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_num_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_array</span><span class="o">=</span><span class="n">as_array</span><span class="p">)</span></div>

<span class="c1">#ivy.array.gradients</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<div class="viewcode-block" id="stop_gradient"><a class="viewcode-back" href="../../../functional/ivy/gradients/stop_gradient/stop_gradient_array.html#ivy.array.array_methods.stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">stop_gradient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">preserve_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stop_gradient. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stop_gradient also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array for which to stop the gradient.</span>
<span class="sd">    preserve_type</span>
<span class="sd">        Whether to preserve gradient computation on ivy.Array instances. Default is</span>
<span class="sd">        True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The same array x, but with no gradient information.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.stop_gradient(preserve_type=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 2., 3.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="adam_step"><a class="viewcode-back" href="../../../functional/ivy/gradients/adam_step/adam_step_array.html#ivy.array.array_methods.adam_step">[docs]</a><span class="k">def</span> <span class="nf">adam_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">mw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">vw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.adam_step. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.adam_step also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    mw</span>
<span class="sd">        running average of the gradients.</span>
<span class="sd">    vw</span>
<span class="sd">        running average of second moments of the gradients.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The adam step delta.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; mw = ivy.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; vw = ivy.ones(1)</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array(3)</span>
<span class="sd">    &gt;&gt;&gt; adam_step_delta = dcdw.adam_step(mw, vw, step)</span>
<span class="sd">    &gt;&gt;&gt; print(adam_step_delta)</span>
<span class="sd">    (ivy.array([0.182, 0.182, 0.182]),</span>
<span class="sd">     ivy.array([0.9, 0.9, 0.9]),</span>
<span class="sd">     ivy.array([0.999, 0.999, 0.999]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="optimizer_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/optimizer_update/optimizer_update_array.html#ivy.array.array_methods.optimizer_update">[docs]</a><span class="k">def</span> <span class="nf">optimizer_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">effective_grad</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.optimizer_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.optimizer_update also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    effective_grad</span>
<span class="sd">        Effective gradients of the cost c with respect to the weights ws,</span>
<span class="sd">        [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the optimizer updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; lr = 3e-4</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(ws_new)</span>
<span class="sd">    ivy.array([1., 2., 3.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gradient_descent_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/gradient_descent_update/gradient_descent_update_array.html#ivy.array.array_methods.gradient_descent_update">[docs]</a><span class="k">def</span> <span class="nf">gradient_descent_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gradient_descent_update.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.gradient_descent_update also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be</span>
<span class="sd">        updated relative to the gradient.</span>
<span class="sd">    inplace</span>
<span class="sd">        Whether to perform the operation inplace, for backends which support inplace</span>
<span class="sd">        variable updates, and handle gradients behind the scenes such as PyTorch.</span>
<span class="sd">        If the update step should form part of a computation graph</span>
<span class="sd">        (i.e. higher order optimization), then this should be set to False.</span>
<span class="sd">        Default is ``True``, provided the backend framework supports it.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new weights, following the gradient descent updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.array([[1., 2, 3],</span>
<span class="sd">    ...                [4, 6, 1],</span>
<span class="sd">    ...                [1, 0, 7]])</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([[0.5, 0.2, 0.1],</span>
<span class="sd">    ...                   [0.3, 0.6, 0.4],</span>
<span class="sd">    ...                   [0.4, 0.7, 0.2]])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.1)</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.gradient_descent_update(dcdw, lr, stop_gradients = True)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    ivy.array([[ 0.95,  1.98,  2.99],</span>
<span class="sd">    ...        [ 3.97,  5.94,  0.96],</span>
<span class="sd">    ...        [ 0.96, -0.07,  6.98]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="lars_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/lars_update/lars_update_array.html#ivy.array.array_methods.lars_update">[docs]</a><span class="k">def</span> <span class="nf">lars_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.lars_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.lars_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate, the rate at which the weights should be updated relative to</span>
<span class="sd">        the gradient.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LARS updates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="adam_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/adam_update/adam_update_array.html#ivy.array.array_methods.adam_update">[docs]</a><span class="k">def</span> <span class="nf">adam_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.adam_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.adam_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, and also new mw and vw, following the adam</span>
<span class="sd">        updates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="lamb_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/lamb_update/lamb_update_array.html#ivy.array.array_methods.lamb_update">[docs]</a><span class="k">def</span> <span class="nf">lamb_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">max_trust_ratio</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.lamb_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.lamb_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    max_trust_ratio</span>
<span class="sd">        The maximum value for the trust ratio. Default is 10.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LAMB updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.array([1., 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([0.5,0.2,0.1])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.1)</span>
<span class="sd">    &gt;&gt;&gt; vw_tm1 = ivy.zeros(1)</span>
<span class="sd">    &gt;&gt;&gt; mw_tm1 = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array(1)</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.lamb_update(dcdw, lr, mw_tm1, vw_tm1, step)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    (ivy.array([0.784, 1.78 , 2.78 ]),</span>
<span class="sd">    ... ivy.array([0.05, 0.02, 0.01]),</span>
<span class="sd">    ... ivy.array([2.5e-04, 4.0e-05, 1.0e-05]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.layers</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<div class="viewcode-block" id="linear"><a class="viewcode-back" href="../../../functional/ivy/layers/linear/linear_array.html#ivy.array.array_methods.linear">[docs]</a><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.linear. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.linear also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array to compute linear transformation on.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,in_features]*</span>
<span class="sd">    weight</span>
<span class="sd">        The weight matrix. *[outer_batch_shape,out_features,in_features]*</span>
<span class="sd">    bias</span>
<span class="sd">        The bias vector, default is ``None``. *[outer_batch_shape,out_features]*</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Result array of the linear transformation.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,out_features]*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3], \</span>
<span class="sd">                       [4.4, 5.5, 6.6], \</span>
<span class="sd">                       [7.7, 8.8, 9.9]])</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.array([[1., 2., 3.], \</span>
<span class="sd">                       [4., 5., 6.], \</span>
<span class="sd">                       [7., 8., 9.]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([1., 0., -1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.linear(w, bias=b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 16.4,  35.2,  54. ],</span>
<span class="sd">               [ 36.2,  84.7, 133. ],</span>
<span class="sd">               [ 56. , 134. , 212. ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="dropout"><a class="viewcode-back" href="../../../functional/ivy/layers/dropout/dropout_array.html#ivy.array.array_methods.dropout">[docs]</a><span class="k">def</span> <span class="nf">dropout</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="dropout1d"><a class="viewcode-back" href="../../../functional/ivy/layers/dropout1d/dropout1d_array.html#ivy.array.array_methods.dropout1d">[docs]</a><span class="k">def</span> <span class="nf">dropout1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="scaled_dot_product_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/scaled_dot_product_attention/scaled_dot_product_attention_array.html#ivy.array.array_methods.scaled_dot_product_attention">[docs]</a><span class="k">def</span> <span class="nf">scaled_dot_product_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="multi_head_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/multi_head_attention/multi_head_attention_array.html#ivy.array.array_methods.multi_head_attention">[docs]</a><span class="k">def</span> <span class="nf">multi_head_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">,</span>
    <span class="n">num_heads</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv1d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d/conv1d_array.html#ivy.array.array_methods.conv1d">[docs]</a><span class="k">def</span> <span class="nf">conv1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.conv1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,w,d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1., 2.], [3., 4.], [6., 7.], [9., 11.]]])  # NWC</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[0., 1.], [1., 1.]]])  # WIO (I == C)</span>
<span class="sd">    &gt;&gt;&gt; result = x.conv1d(filters, (1,), &#39;VALID&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    ivy.array([[[ 2.,  3.],</span>
<span class="sd">    ...         [ 4.,  7.],</span>
<span class="sd">    ...         [ 7., 13.],</span>
<span class="sd">    ...         [11., 20.]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv1d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d_transpose/conv1d_transpose_array.html#ivy.array.array_methods.conv1d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv1d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="depthwise_conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/depthwise_conv2d/depthwise_conv2d_array.html#ivy.array.array_methods.depthwise_conv2d">[docs]</a><span class="k">def</span> <span class="nf">depthwise_conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.depthwise_conv2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.depthwise_conv2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,h,w,d]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in]*. (d_in must be the same as d from self)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.depthwise_conv2d(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    (1, 64, 64, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv2d/conv2d_array.html#ivy.array.array_methods.conv2d">[docs]</a><span class="k">def</span> <span class="nf">conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.conv2d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.conv2d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[[1.], [2.0],[3.]],</span>
<span class="sd">    ...                 [[1.], [2.0],[3.]],</span>
<span class="sd">    ...                 [[1.], [2.0],[3.]]]]) #NHWC</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[[0.]], [[1.]], [[0.]]],</span>
<span class="sd">    ...                      [[[0.]], [[1.]], [[0.]]],</span>
<span class="sd">    ...                      [[[0.]], [[1.]], [[0.]]]]) #HWIO</span>
<span class="sd">    &gt;&gt;&gt; result = x.conv2d(filters, 1, &#39;SAME&#39;, data_format=&#39;NHWC&#39;,</span>
<span class="sd">    ...    dilations= 1)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    ivy.array([[</span>
<span class="sd">              [[2.],[4.],[6.]],</span>
<span class="sd">              [[3.],[6.],[9.]],</span>
<span class="sd">              [[2.],[4.],[6.]]</span>
<span class="sd">              ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv3d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d/conv3d_array.html#ivy.array.array_methods.conv3d">[docs]</a><span class="k">def</span> <span class="nf">conv3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv3d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d_transpose/conv3d_transpose_array.html#ivy.array.array_methods.conv3d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv3d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="lstm_update"><a class="viewcode-back" href="../../../functional/ivy/layers/lstm_update/lstm_update_array.html#ivy.array.array_methods.lstm_update">[docs]</a><span class="k">def</span> <span class="nf">lstm_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">init_h</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">init_c</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">recurrent_kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">recurrent_bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lstm_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">init_h</span><span class="p">,</span>
        <span class="n">init_c</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">recurrent_kernel</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">recurrent_bias</span><span class="o">=</span><span class="n">recurrent_bias</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="c1">#ivy.array.linear_algebra</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="n">inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="matmul"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matmul/matmul_array.html#ivy.array.array_methods.matmul">[docs]</a><span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">transpose_a</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">transpose_b</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    ------------------------</span>

<span class="sd">    With :class:`ivy.Array` instance inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3., 2.])</span>
<span class="sd">    &gt;&gt;&gt; z = x.matmul(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(11.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cholesky"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cholesky/cholesky_array.html#ivy.array.array_methods.cholesky">[docs]</a><span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">upper</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cholesky. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cholesky also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, M) and whose innermost two dimensions form</span>
<span class="sd">        square symmetric positive-definite matrices. Should have a floating-point</span>
<span class="sd">        data type.</span>
<span class="sd">    upper</span>
<span class="sd">        If True, the result must be the upper-triangular Cholesky factor U. If</span>
<span class="sd">        False, the result must be the lower-triangular Cholesky factor L.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the Cholesky factors for each square matrix. If upper is</span>
<span class="sd">        False, the returned array must contain lower-triangular matrices; otherwise,</span>
<span class="sd">        the returned array must contain upper-triangular matrices. The returned</span>
<span class="sd">        array must have a floating-point data type determined by Type Promotion</span>
<span class="sd">        Rules and must have the same shape as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[4.0, 1.0, 2.0, 0.5, 2.0],</span>
<span class="sd">    ...               [1.0, 0.5, 0.0, 0.0, 0.0],</span>
<span class="sd">    ...               [2.0, 0.0, 3.0, 0.0, 0.0],</span>
<span class="sd">    ...               [0.5, 0.0, 0.0, 0.625, 0.0],</span>
<span class="sd">    ...               [2.0, 0.0, 0.0, 0.0, 16.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cholesky(upper=&#39;false&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 2.  ,  0.5 ,  1.  ,  0.25,  1.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.5 , -1.  , -0.25, -1.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.  ,  1.  , -0.5 , -2.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.  ,  0.  ,  0.5 , -3.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.  ,  0.  ,  0.  ,  1.  ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cross"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cross/cross_array.html#ivy.array.array_methods.cross">[docs]</a><span class="k">def</span> <span class="nf">cross</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cross. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cross also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis (dimension) of x1 and x2 containing the vectors for which to</span>
<span class="sd">        compute (default: -1) the cross product.vIf set to -1, the function</span>
<span class="sd">        computes the cross product for vectors defined by the last axis (dimension).</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products. The returned array must</span>
<span class="sd">        have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 1., 0.])</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([0., 0., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="det"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/det/det_array.html#ivy.array.array_methods.det">[docs]</a><span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2.,4.],[6.,7.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.det()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(-10.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="diagonal"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diagonal/diagonal_array.html#ivy.array.array_methods.diagonal">[docs]</a><span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="diag"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diag/diag_array.html#ivy.array.array_methods.diag">[docs]</a><span class="k">def</span> <span class="nf">diag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.diag.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.diag also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 1, 2],</span>
<span class="sd">    &gt;&gt;&gt;                [3, 4, 5],</span>
<span class="sd">    &gt;&gt;&gt;                [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; x.diag(k=1)</span>
<span class="sd">    ivy.array([1, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="eigh"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/eigh/eigh_array.html#ivy.array.array_methods.eigh">[docs]</a><span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="eigvalsh"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/eigvalsh/eigvalsh_array.html#ivy.array.array_methods.eigvalsh">[docs]</a><span class="k">def</span> <span class="nf">eigvalsh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">UPLO</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.eigvalsh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.eigvalsh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array having shape (..., M, M) and whose innermost two dimensions form</span>
<span class="sd">        square matrices. Must have floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the computed eigenvalues. The returned array must have shape</span>
<span class="sd">        (..., M) and have the same data type as x.</span>


<span class="sd">    This function conforms to the `Array API Standard</span>
<span class="sd">    &lt;https://data-apis.org/array-api/latest/&gt;`_. This docstring is an extension of the</span>
<span class="sd">    `docstring &lt;https://data-apis.org/array-api/latest/extensions/generated/signatures.linalg.eigvalsh.html&gt;`_ </span>
<span class="sd">    in the standard.</span>

<span class="sd">    Both the description and the type hints above assumes an array input for simplicity,</span>
<span class="sd">    but this function is *nestable*, and therefore also accepts :class:`ivy.Container`</span>
<span class="sd">    instances in place of any of the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1.0,2.0],[2.0,1.0]]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.eigvalsh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-1.,  3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="inner"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inner/inner_array.html#ivy.array.array_methods.inner">[docs]</a><span class="k">def</span> <span class="nf">inner</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="inv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inv/inv_array.html#ivy.array.array_methods.inv">[docs]</a><span class="k">def</span> <span class="nf">inv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inv.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.inv also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.0, 2.0],[3.0, 4.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.inv(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-2., 1.],[1.5, -0.5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_norm/matrix_norm_array.html#ivy.array.array_methods.matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span> <span class="s2">&quot;nuc&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.matrix_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.matrix_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array having shape (..., M, N) and whose innermost two dimensions</span>
<span class="sd">        form MxN matrices. Should have a floating-point data type.</span>
<span class="sd">    ord</span>
<span class="sd">        Order of the norm. Default is &quot;fro&quot;.</span>
<span class="sd">    axis</span>
<span class="sd">        specifies the axes that hold 2-D matrices. Default: (-2, -1).</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are normed over are left in</span>
<span class="sd">        the result as dimensions with size one. With this option the result will</span>
<span class="sd">        broadcast correctly against the original x. Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Matrix norm of the array at specified axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3], [1.0, 2.0, 3.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_norm(ord=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(6.3)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.arange(8, dtype=float).reshape((2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_norm(ord=&quot;nuc&quot;, axis=(2, 1), keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[[ 4.24]],</span>
<span class="sd">            [[11.4 ]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="matrix_rank"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_rank/matrix_rank_array.html#ivy.array.array_methods.matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">matrix_rank</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.matrix_rank. This method returns</span>
<span class="sd">    the rank (i.e., number of non-zero singular values) of a matrix (or a stack of</span>
<span class="sd">    matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two dimensions</span>
<span class="sd">        form ``MxN`` matrices. Should have a floating-point data type.</span>

<span class="sd">    atol</span>
<span class="sd">        absolute tolerance. When None it’s considered to be zero.</span>

<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values. Singular values approximately</span>
<span class="sd">        less than or equal to ``rtol * largest_singular_value`` are set to zero.</span>
<span class="sd">        If a ``float``, the value is equivalent to a zero-dimensional array having</span>
<span class="sd">        a floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``) and must be broadcast against each matrix.</span>
<span class="sd">        If an ``array``, must have a floating-point data type and must be</span>
<span class="sd">        compatible with ``shape(x)[:-2]`` (see :ref:`broadcasting`).</span>
<span class="sd">        If ``None``, the default value is ``max(M, N) * eps``, where ``eps`` must</span>
<span class="sd">        be the machine epsilon associated with the floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion` (as applied to ``x``).</span>
<span class="sd">        Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the ranks. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and</span>
<span class="sd">        must have shape ``(...)``</span>
<span class="sd">        (i.e., must have a shape equal to ``shape(x)[:-2]``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1. Full Matrix</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(2.)</span>

<span class="sd">    2. Rank Deficient Matrix</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 0.], [0., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(1.)</span>

<span class="sd">    3. 1 Dimension - rank 1 unless all 0</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(1.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="matrix_transpose"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_transpose/matrix_transpose_array.html#ivy.array.array_methods.matrix_transpose">[docs]</a><span class="k">def</span> <span class="nf">matrix_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes a matrix (or a stack of matrices) ``x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the transpose for each matrix and having shape</span>
<span class="sd">        ``(..., N, M)``. The returned array must have the same data</span>
<span class="sd">        type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [0., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.matrix_transpose(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1., 0.],</span>
<span class="sd">               [2., 3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="outer"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/outer/outer_array.html#ivy.array.array_methods.outer">[docs]</a><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="pinv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/pinv/pinv_array.html#ivy.array.array_methods.pinv">[docs]</a><span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    x = ivy.array([[1., 2.],</span>
<span class="sd">    ...            [3., 4.]])</span>
<span class="sd">    y = pinv(x, None, None)</span>
<span class="sd">    print(y)</span>
<span class="sd">    ivy.array([[-2., 1.],</span>
<span class="sd">    ...        [1.5, -0.5]])</span>

<span class="sd">    x = ivy.array([[1., 2.],</span>
<span class="sd">    ...            [3., 4.]])</span>
<span class="sd">    out = ivy.array()</span>
<span class="sd">    pinv(x, 0, out)</span>
<span class="sd">    print(out)</span>
<span class="sd">    ivy.array([[0.0426, 0.0964],</span>
<span class="sd">    ...       [0.0605, 0.1368]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="qr"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/qr/qr_array.html#ivy.array.array_methods.qr">[docs]</a><span class="k">def</span> <span class="nf">qr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reduced&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="slogdet"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/slogdet/slogdet_array.html#ivy.array.array_methods.slogdet">[docs]</a><span class="k">def</span> <span class="nf">slogdet</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.slogdet. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.slogdet also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, M) and whose innermost two dimensions</span>
<span class="sd">        form square matrices. Should have a floating-point data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        This function returns NamedTuple with two values -</span>
<span class="sd">            sign:</span>
<span class="sd">            An array containing a number representing the sign of the determinant</span>
<span class="sd">            for each square matrix.</span>

<span class="sd">            logabsdet:</span>
<span class="sd">            An array containing natural log of the absolute determinant of each</span>
<span class="sd">            square matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.slogdet()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    slogdet(sign=ivy.array(-1.), logabsdet=ivy.array(0.6931472))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/solve/solve_array.html#ivy.array.array_methods.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="svd"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svd/svd_array.html#ivy.array.array_methods.svd">[docs]</a><span class="k">def</span> <span class="nf">svd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">compute_uv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">full_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="n">compute_uv</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="n">full_matrices</span><span class="p">)</span></div>

<div class="viewcode-block" id="svdvals"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svdvals/svdvals_array.html#ivy.array.array_methods.svdvals">[docs]</a><span class="k">def</span> <span class="nf">svdvals</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tensordot"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/tensordot/tensordot_array.html#ivy.array.array_methods.tensordot">[docs]</a><span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="trace"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/trace/trace_array.html#ivy.array.array_methods.trace">[docs]</a><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.trace.</span>
<span class="sd">    This method Returns the sum along the specified diagonals of a matrix (or a</span>
<span class="sd">    stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    offset</span>
<span class="sd">        Offset of the diagonal from the main diagonal. Can be both positive and</span>
<span class="sd">        negative. Defaults to 0.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the traces and whose shape is determined by removing</span>
<span class="sd">        the last two dimensions and storing the traces in the last array dimension.</span>
<span class="sd">        For example, if ``x`` has rank ``k`` and shape ``(I, J, K, ..., L, M, N)``,</span>
<span class="sd">        then an output array has rank ``k-2`` and shape ``(I, J, K, ..., L)`` where</span>

<span class="sd">        ::</span>

<span class="sd">        out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])</span>

<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.trace()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(5.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2., 4.], [6., 5., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Array.trace(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(6.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="vecdot"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vecdot/vecdot_array.html#ivy.array.array_methods.vecdot">[docs]</a><span class="k">def</span> <span class="nf">vecdot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="vector_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_norm/vector_norm_array.html#ivy.array.array_methods.vector_norm">[docs]</a><span class="k">def</span> <span class="nf">vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="vector_to_skew_symmetric_matrix"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_to_skew_symmetric_matrix/vector_to_skew_symmetric_matrix_array.html#ivy.array.array_methods.vector_to_skew_symmetric_matrix">[docs]</a><span class="k">def</span> <span class="nf">vector_to_skew_symmetric_matrix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="vander"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vander/vander_array.html#ivy.array.array_methods.vander">[docs]</a><span class="k">def</span> <span class="nf">vander</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">increasing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.vander.</span>
<span class="sd">    This method Returns the Vandermonde matrix of the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        1-D input array.</span>
<span class="sd">    N</span>
<span class="sd">        Number of columns in the output. If N is not specified,</span>
<span class="sd">        a square array is returned (N = len(x))</span>
<span class="sd">    increasing</span>
<span class="sd">        Order of the powers of the columns. If True, the powers increase</span>
<span class="sd">        from left to right, if False (the default) they are reversed.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the Vandermonde matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.vander(x)</span>
<span class="sd">    ivy.array(</span>
<span class="sd">    [[  1,   1,   1,   1],</span>
<span class="sd">        [  8,   4,   2,   1],</span>
<span class="sd">        [ 27,   9,   3,   1],</span>
<span class="sd">        [125,  25,   5,   1]]</span>
<span class="sd">        )</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.vander(x, N=3)</span>
<span class="sd">    ivy.array(</span>
<span class="sd">    [[ 1,  1,  1],</span>
<span class="sd">        [ 4,  2,  1],</span>
<span class="sd">        [ 9,  3,  1],</span>
<span class="sd">        [25,  5,  1]]</span>
<span class="sd">        )</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.vander(x, N=3, increasing=True)</span>
<span class="sd">    ivy.array(</span>
<span class="sd">    [[ 1,  1,  1],</span>
<span class="sd">        [ 1,  2,  4],</span>
<span class="sd">        [ 1,  3,  9],</span>
<span class="sd">        [ 1,  5, 25]]</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.losses</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/cross_entropy/cross_entropy_array.html#ivy.array.array_methods.cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.cross_entropy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.cross_entropy also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array containing the predicted labels.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``,</span>
<span class="sd">        the cross-entropy will be computed along the last dimension.</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 0, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0.25, 0.25, 0.25, 0.25])</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(1.3862944)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="binary_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/binary_cross_entropy/binary_cross_entropy_array.html#ivy.array.array_methods.binary_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">binary_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.binary_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.binary_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array containing Predicted labels.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The binary cross entropy between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0.7, 0.8, 0.2])</span>
<span class="sd">    &gt;&gt;&gt; z = x.binary_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([0.357, 0.223, 0.223])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sparse_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/sparse_cross_entropy/sparse_cross_entropy_array.html#ivy.array.array_methods.sparse_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">sparse_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sparse_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.sparse_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing the true labels as logits.</span>
<span class="sd">    pred</span>
<span class="sd">        input array containing the predicted labels as logits.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``, the</span>
<span class="sd">        cross-entropy will be computed along the last dimension. Default: ``-1``.</span>
<span class="sd">        epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The sparse cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0.7, 0.8, 0.2])</span>
<span class="sd">    &gt;&gt;&gt; z = x.sparse_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([0.223, 0.223, 0.357])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.manipulation</span>
<span class="c1"># For Review</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<div class="viewcode-block" id="concat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/concat/concat_array.html#ivy.array.array_methods.concat">[docs]</a><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.concat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.concat also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input arrays to join. The arrays must have the same shape, except in the</span>
<span class="sd">        dimension specified by axis.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which the arrays will be joined. If axis is None, arrays</span>
<span class="sd">        must be flattened before concatenation. If axis is negative, axis on</span>
<span class="sd">        which to join arrays is determined by counting from the top. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array containing the concatenated values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="expand_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/expand_dims/expand_dims_array.html#ivy.array.array_methods.expand_dims">[docs]</a><span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.expand_dims. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.expand_dims also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        position in the expanded array where a new axis (dimension) of size one</span>
<span class="sd">        will be added. If array ``self`` has the rank of ``N``, the ``axis`` needs</span>
<span class="sd">        to be between ``[-N-1, N]``. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of ``self``, but with its dimension added</span>
<span class="sd">        by one in a given ``axis``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-4.7, -2.3, 0.7]) #x.shape-&gt;(3,)</span>
<span class="sd">    &gt;&gt;&gt; y = x.expand_dims() #y.shape-&gt;(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-4.7, -2.3,  0.7]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="flip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/flip/flip_array.html#ivy.array.array_methods.flip">[docs]</a><span class="k">def</span> <span class="nf">flip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.flip. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flip also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which to flip. If axis is None, all</span>
<span class="sd">        input array axes are flipped. If axis is negative, axis</span>
<span class="sd">        is counted from the last dimension. If provided more than</span>
<span class="sd">        one axis, only the specified axes. Default: None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array having the same data type and</span>
<span class="sd">        shape as``self`` and whose elements, relative</span>
<span class="sd">        to ``self``, are reordered.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.flip()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([3, 2, 1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.flip(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6, 5, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="permute_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/permute_dims/permute_dims_array.html#ivy.array.array_methods.permute_dims">[docs]</a><span class="k">def</span> <span class="nf">permute_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.permute_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.permute_dims also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../functional/ivy/manipulation/reshape/reshape_array.html#ivy.array.array_methods.reshape">[docs]</a><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.reshape. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.reshape also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    shape</span>
<span class="sd">        The new shape should be compatible with the original shape.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean indicating whether or not to copy the input array.</span>
<span class="sd">        If True, the function must always copy.</span>
<span class="sd">        If False, the function must never copy and must</span>
<span class="sd">        raise a ValueError in case a copy would be necessary.</span>
<span class="sd">        If None, the function must reuse existing memory buffer if possible</span>
<span class="sd">        and copy otherwise. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>
<span class="sd">    order</span>
<span class="sd">        Read the elements of the input array using this index order,</span>
<span class="sd">        and place the elements into the reshaped array using this index order.</span>
<span class="sd">        ‘C’ means to read / write the elements using C-like index order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first axis index</span>
<span class="sd">        changing slowest.</span>
<span class="sd">        ‘F’ means to read / write the elements using Fortran-like index order, with</span>
<span class="sd">        the first index changing fastest, and the last index changing slowest.</span>
<span class="sd">        Note that the ‘C’ and ‘F’ options take no account of the memory layout</span>
<span class="sd">        of the underlying array, and only refer to the order of indexing.</span>
<span class="sd">        Default order is &#39;C&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array having the same data type as ``self``</span>
<span class="sd">        and  elements as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.],[3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.reshape((3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0., 1.],</span>
<span class="sd">               [2., 3.],</span>
<span class="sd">               [4., 5.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.],[3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.reshape((3,2), order=&#39;F&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0., 4.],</span>
<span class="sd">               [3., 2.],</span>
<span class="sd">               [1., 5.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../../functional/ivy/manipulation/roll/roll_array.html#ivy.array.array_methods.roll">[docs]</a><span class="k">def</span> <span class="nf">roll</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.roll. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.roll also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    shift</span>
<span class="sd">        number of places by which the elements are shifted. If ``shift`` is a tuple,</span>
<span class="sd">        then ``axis`` must be a tuple of the same size, and each of the given axes</span>
<span class="sd">        must be shifted by the corresponding element in ``shift``. If ``shift`` is</span>
<span class="sd">        an ``int`` and ``axis`` a tuple, then the same ``shift`` must be used for</span>
<span class="sd">        all specified axes. If a shift is positive, then array elements must be</span>
<span class="sd">        shifted positively (toward larger indices) along the dimension of ``axis``.</span>
<span class="sd">        If a shift is negative, then array elements must be shifted negatively</span>
<span class="sd">        (toward smaller indices) along the dimension of ``axis``.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which elements to shift. If ``axis`` is ``None``, the</span>
<span class="sd">        array must be flattened, shifted, and then restored to its original shape.</span>
<span class="sd">        Default ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array having the same data type as ``self`` and whose elements,</span>
<span class="sd">        relative to ``self``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.roll(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2., 0., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../functional/ivy/manipulation/squeeze/squeeze_array.html#ivy.array.array_methods.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.squeeze. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.squeeze also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0.],[ 1.]]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.squeeze(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0., 1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/stack/stack_array.html#ivy.array.array_methods.stack">[docs]</a><span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stack. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stack also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([ivy.array([1,2]),ivy.native_array([3,4])])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([ivy.array([5,6]),ivy.array([7,8])])</span>
<span class="sd">    &gt;&gt;&gt; x.stack([y],axis=1)</span>
<span class="sd">    ivy.array([[1, 3, 5, 7],</span>
<span class="sd">        [2, 4, 6, 8]])</span>
<span class="sd">    &gt;&gt;&gt; x.stack([y],axis=0)</span>
<span class="sd">    ivy.array([[1, 2],</span>
<span class="sd">        [3, 4],</span>
<span class="sd">        [5, 6],</span>
<span class="sd">        [7, 8]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="clip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/clip/clip_array.html#ivy.array.array_methods.clip">[docs]</a><span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x_min</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.clip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.clip also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to clip.</span>
<span class="sd">    x_min</span>
<span class="sd">        Minimum value.</span>
<span class="sd">    x_max</span>
<span class="sd">        Maximum value.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of self, but where values &lt; x_min are replaced</span>
<span class="sd">        with x_min, and those &gt; x_max with x_max.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip(1., 5.)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 1., 2., 3., 4., 5., 5., 5., 5., 5.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="constant_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/constant_pad/constant_pad_array.html#ivy.array.array_methods.constant_pad">[docs]</a><span class="k">def</span> <span class="nf">constant_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.constant_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.constant_pad also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.constant_pad(pad_width = [[2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1., 2., 3., 0., 0., 0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/repeat/repeat_array.html#ivy.array.array_methods.repeat">[docs]</a><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">repeats</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.repeat. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.repeat also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y= x.repeat(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1., 1., 2., 2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../../functional/ivy/manipulation/split/split_array.html#ivy.array.array_methods.split">[docs]</a><span class="k">def</span> <span class="nf">split</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_or_size_splits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">with_remainder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.split. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array to be divided into sub-arrays.</span>
<span class="sd">    num_or_size_splits</span>
<span class="sd">        Number of equal arrays to divide the array into along the given axis if an</span>
<span class="sd">        integer. The size of each split element if a sequence of integers. Default</span>
<span class="sd">        is to divide into as many 1-dimensional arrays as the axis dimension.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to split, default is ``0``.</span>
<span class="sd">    with_remainder</span>
<span class="sd">        If the tensor does not split evenly, then store the last remainder entry.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A list of sub-arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([4, 6, 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.split()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([4]),ivy.array([6]),ivy.array([5]),ivy.array([3])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">num_or_size_splits</span><span class="o">=</span><span class="n">num_or_size_splits</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">with_remainder</span><span class="o">=</span><span class="n">with_remainder</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="swapaxes"><a class="viewcode-back" href="../../../functional/ivy/manipulation/swapaxes/swapaxes_array.html#ivy.array.array_methods.swapaxes">[docs]</a><span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axis0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.swap_axes. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tile"><a class="viewcode-back" href="../../../functional/ivy/manipulation/tile/tile_array.html#ivy.array.array_methods.tile">[docs]</a><span class="k">def</span> <span class="nf">tile</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">reps</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tile. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.tile also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0], [1], [2]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.tile((3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0,0],</span>
<span class="sd">               [1,1],</span>
<span class="sd">               [2,2],</span>
<span class="sd">               [0,0],</span>
<span class="sd">               [1,1],</span>
<span class="sd">               [2,2],</span>
<span class="sd">               [0,0],</span>
<span class="sd">               [1,1],</span>
<span class="sd">               [2,2]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="unstack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/unstack/unstack_array.html#ivy.array.array_methods.unstack">[docs]</a><span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.unstack. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unstack also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to unstack.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis for which to unpack the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        Whether to keep dimension 1 in the unstack dimensions. Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        List of arrays, unpacked along specified dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unstack(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([1, 2]), ivy.array([3, 4])]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unstack(axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([[1],</span>
<span class="sd">            [3]]), ivy.array([[2],</span>
<span class="sd">            [4]])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="zero_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/zero_pad/zero_pad_array.html#ivy.array.array_methods.zero_pad">[docs]</a><span class="k">def</span> <span class="nf">zero_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.zero_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zero_pad also applies</span>
<span class="sd">    to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.norms</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">abc</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<div class="viewcode-block" id="layer_norm"><a class="viewcode-back" href="../../../functional/ivy/norms/layer_norm/layer_norm_array.html#ivy.array.array_methods.layer_norm">[docs]</a><span class="k">def</span> <span class="nf">layer_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">normalized_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">_MIN_BASE</span><span class="p">,</span>
    <span class="n">new_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.layer_norm. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.layer_norm also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array</span>
<span class="sd">    normalized_idxs</span>
<span class="sd">        Indices to apply the normalization to.</span>
<span class="sd">    weight</span>
<span class="sd">        Learnable gamma variables for elementwise post-multiplication,</span>
<span class="sd">        default is ``None``.</span>
<span class="sd">    bias</span>
<span class="sd">        Learnable beta variables for elementwise post-addition, default is ``None``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        small constant to add to the denominator, use global ivy._MIN_BASE by</span>
<span class="sd">        default.</span>
<span class="sd">    new_std</span>
<span class="sd">        The standard deviation of the new normalized values. Default is 1.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The layer after applying layer normalization.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0976, -0.3452,  1.2740],</span>
<span class="sd">    ...                   [0.1047,  0.5886,  1.2732],</span>
<span class="sd">    ...                   [0.7696, -1.7024, -2.2518]])</span>
<span class="sd">    &gt;&gt;&gt; norm = x.layer_norm([0, 1], epsilon=0.001,</span>
<span class="sd">    ...                     new_std=1.5, weight=0.5, bias=[0.5, 0.02, 0.1])</span>
<span class="sd">    &gt;&gt;&gt; print(norm)</span>
<span class="sd">    ivy.array([[ 0.826, -0.178, 0.981 ],</span>
<span class="sd">               [ 0.831,  0.421, 0.981 ],</span>
<span class="sd">               [ 1.26 , -1.05 , -1.28 ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.random</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="random_uniform"><a class="viewcode-back" href="../../../functional/ivy/random/random_uniform/random_uniform_array.html#ivy.array.array_methods.random_uniform">[docs]</a><span class="k">def</span> <span class="nf">random_uniform</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.random_uniform. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.random_uniform also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lower boundary of the output interval. All values generated will be</span>
<span class="sd">        greater than or equal to ``low``. If array, must have same shape as</span>
<span class="sd">        ``high``.</span>
<span class="sd">    high</span>
<span class="sd">        Upper boundary of the output interval. All the values generated will be</span>
<span class="sd">        less than ``high``. If array, must have same shape as ``low``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized uniform distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[9.8, 3.4], [5.8, 7.2]])</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.2)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([[10.1 ,  6.53],</span>
<span class="sd">               [ 7.94,  8.85]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([8.7, 9.3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([12.8, 14.5])</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(y)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="random_normal"><a class="viewcode-back" href="../../../functional/ivy/random/random_normal/random_normal_array.html#ivy.array.array_methods.random_normal">[docs]</a><span class="k">def</span> <span class="nf">random_normal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">std</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.random_normal. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.random_normal also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The mean of the normal distribution to sample from. Default is ``0.0``.</span>
<span class="sd">    std</span>
<span class="sd">        The standard deviation of the normal distribution to sample from.</span>
<span class="sd">        Must be non-negative. Default is ``1.0``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``mean`` and ``std`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[9.8, 3.4], [5.8, 7.2]])</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.2)</span>
<span class="sd">    ivy.array([[19.   , -6.44 ],</span>
<span class="sd">               [ 5.72 ,  0.235]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([[18.7 , 25.2 ],</span>
<span class="sd">               [27.5 , -3.22]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([[26.6 , 12.1 ],</span>
<span class="sd">               [ 4.56,  5.49]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([[ 1.02, -1.39],</span>
<span class="sd">               [14.2 , -1.  ]])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([[ 7.72, -8.32],</span>
<span class="sd">               [ 4.95, 15.8 ]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([8.7, 9.3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([12.8, 14.5])</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y)</span>
<span class="sd">    ivy.array([-10.8,  12.1])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([ 13. , -26.9])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([14.3  , -0.807])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([21.3 ,  3.85])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([ 4.32, 42.2 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="multinomial"><a class="viewcode-back" href="../../../functional/ivy/random/multinomial/multinomial_array.html#ivy.array.array_methods.multinomial">[docs]</a><span class="k">def</span> <span class="nf">multinomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.multinomial. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.multinomial also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The unnormalized probabilities for all elements in population,</span>
<span class="sd">        default is uniform *[batch_shape, population_size]*</span>
<span class="sd">    population_size</span>
<span class="sd">        The size of the population from which to draw samples.</span>
<span class="sd">    num_samples</span>
<span class="sd">        Number of independent samples to draw from the population.</span>
<span class="sd">    batch_size</span>
<span class="sd">        Number of tensors to generate. Default is 1.</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace samples once they&#39;ve been drawn. Default is ``True``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None)</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="randint"><a class="viewcode-back" href="../../../functional/ivy/random/randint/randint_array.html#ivy.array.array_methods.randint">[docs]</a><span class="k">def</span> <span class="nf">randint</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.randint. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.randint also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lowest integer that can be drawn from the distribution.</span>
<span class="sd">    high</span>
<span class="sd">        One above the highest integer that can be drawn from the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default integer data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array with the given shape filled with integers from</span>
<span class="sd">        the uniform distribution in the “half-open” interval [low, high)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2], [0, 5]])</span>
<span class="sd">    &gt;&gt;&gt; x.randint(10)</span>
<span class="sd">    ivy.array([[1, 5],</span>
<span class="sd">               [9, 7]])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(8, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([[6, 5],</span>
<span class="sd">               [0, 5]])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(9, dtype=&#39;int8&#39;)</span>
<span class="sd">    ivy.array([[1, 2],</span>
<span class="sd">               [7, 7]])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(14, device=&#39;cpu&#39;, dtype=&#39;int16&#39;)</span>
<span class="sd">    ivy.array([[6, 5],</span>
<span class="sd">               [0, 5]])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(16, device=&#39;cpu&#39;, dtype=&#39;int64&#39;, out=z)</span>
<span class="sd">    ivy.array([[1, 2],</span>
<span class="sd">               [7, 7]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([23, 25, 98])</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y)</span>
<span class="sd">    ivy.array([ 5, 14, 18])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([20, 13, 46])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, dtype=&#39;int32&#39;)</span>
<span class="sd">    ivy.array([ 9, 18, 33])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int16&#39;)</span>
<span class="sd">    ivy.array([ 9, 20, 85])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((3,))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int64&#39;, out=z)</span>
<span class="sd">    ivy.array([20, 13, 46])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="shuffle"><a class="viewcode-back" href="../../../functional/ivy/random/shuffle/shuffle_array.html#ivy.array.array_methods.shuffle">[docs]</a><span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.shuffle. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.shuffle also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Should have a numeric data type.</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array object, shuffled along the first dimension.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5, 2, 9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.shuffle()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2, 5, 9])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="k">def</span> <span class="nf">beta</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.beta. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.beta also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input Array.</span>
<span class="sd">    alpha</span>
<span class="sd">        The first parameter of the beta distribution.</span>
<span class="sd">    beta</span>
<span class="sd">        The second parameter of the beta distribution.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array.</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized beta distribution with the shape of</span>
<span class="sd">        the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.gamma. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gamma also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input Array.</span>
<span class="sd">    alpha</span>
<span class="sd">        The first parameter of the gamma distribution.</span>
<span class="sd">    beta</span>
<span class="sd">        The second parameter of the gamma distribution.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array.</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized gamma distribution with the shape of</span>
<span class="sd">        the input array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="c1">#ivy.array.searching</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../functional/ivy/searching/argmax/argmax_array.html#ivy.array.array_methods.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">output_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmax also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the maximum value of the flattened array. Deafult: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the array.</span>
<span class="sd">    output_dtype</span>
<span class="sd">        Optional data type of the output array.</span>
<span class="sd">    out</span>
<span class="sd">        If provided, the result will be inserted into this array. It should be of</span>
<span class="sd">        the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if axis is None, a zero-dimensional array containing the index of the first</span>
<span class="sd">        occurrence of the maximum value; otherwise, a non-zero-dimensional array</span>
<span class="sd">        containing the indices of the maximum values. The returned array must have</span>
<span class="sd">        the default array index data type.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">output_dtype</span><span class="o">=</span><span class="n">output_dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../functional/ivy/searching/argmin/argmin_array.html#ivy.array.array_methods.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">int64</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argmin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmin also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the minimum value of the flattened array. Default = None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see Broadcasting). Otherwise, if False, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default = False.</span>
<span class="sd">    dtype</span>
<span class="sd">        An optional output_dtype from: int32, int64. Defaults to int64.</span>
<span class="sd">    out</span>
<span class="sd">        if axis is None, a zero-dimensional array containing the index of the first</span>
<span class="sd">        occurrence of the minimum value; otherwise, a non-zero-dimensional array</span>
<span class="sd">        containing the indices of the minimum values. The returned array must have</span>
<span class="sd">        the default array index data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing the indices of the minimum values across the specified</span>
<span class="sd">        axis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="nonzero"><a class="viewcode-back" href="../../../functional/ivy/searching/nonzero/nonzero_array.html#ivy.array.array_methods.nonzero">[docs]</a><span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">as_tuple</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nonzero also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    as_tuple</span>
<span class="sd">        if True, the output is returned as a tuple of indices, one for each</span>
<span class="sd">        dimension of the input, containing the indices of the true elements in that</span>
<span class="sd">        dimension. If False, the coordinates are returned in a (N, ndim) array,</span>
<span class="sd">        where N is the number of true elements. Default = True.</span>
<span class="sd">    size</span>
<span class="sd">        if specified, the function will return an array of shape (size, ndim).</span>
<span class="sd">        If the number of non-zero elements is fewer than size, the remaining</span>
<span class="sd">        elements will be filled with fill_value. Default = None.</span>
<span class="sd">    fill_value</span>
<span class="sd">        when size is specified and there are fewer than size number of elements,</span>
<span class="sd">        the remaining elements in the output array will be filled with fill_value.</span>
<span class="sd">        Default = 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing the indices of the non-zero values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="n">as_tuple</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../../functional/ivy/searching/where/where_array.html#ivy.array.array_methods.where">[docs]</a><span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.where. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.where also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Where True, yield x1, otherwise yield x2.</span>
<span class="sd">    x1</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        values from which to choose when condition is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with elements from self where condition is True, and elements from</span>
<span class="sd">        x2 otherwise.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="argwhere"><a class="viewcode-back" href="../../../functional/ivy/searching/argwhere/argwhere_array.html#ivy.array.array_methods.argwhere">[docs]</a><span class="k">def</span> <span class="nf">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argwhere. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argwhere also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array for which indices are desired</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Indices for where the boolean array is True.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.set</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>


<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="unique_counts"><a class="viewcode-back" href="../../../functional/ivy/set/unique_counts/unique_counts_array.html#ivy.array.array_methods.unique_counts">[docs]</a><span class="k">def</span> <span class="nf">unique_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.unique_counts. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_counts also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. If ``x`` has more than one dimension, the function must flatten</span>
<span class="sd">        ``x`` and return the unique elements of the flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, counts)`` whose</span>

<span class="sd">        - first element must have the field name ``values`` and must be an</span>
<span class="sd">        array containing the unique elements of ``x``.</span>
<span class="sd">        The array must have the same data type as ``x``.</span>
<span class="sd">        - second element must have the field name ``counts`` and must be an array</span>
<span class="sd">        containing the number of times each unique element occurs in ``x``.</span>
<span class="sd">        The returned array must have same shape as ``values`` and must</span>
<span class="sd">        have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2. , 1. , 0.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_counts()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    Results(values=ivy.array([0.,1.,2.]),counts=ivy.array([2,2,1]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unique_counts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="unique_values"><a class="viewcode-back" href="../../../functional/ivy/set/unique_values/unique_values_array.html#ivy.array.array_methods.unique_values">[docs]</a><span class="k">def</span> <span class="nf">unique_values</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="unique_all"><a class="viewcode-back" href="../../../functional/ivy/set/unique_all/unique_all_array.html#ivy.array.array_methods.unique_all">[docs]</a><span class="k">def</span> <span class="nf">unique_all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unique_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="unique_inverse"><a class="viewcode-back" href="../../../functional/ivy/set/unique_inverse/unique_inverse_array.html#ivy.array.array_methods.unique_inverse">[docs]</a><span class="k">def</span> <span class="nf">unique_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.unique_inverse. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_inverse also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. If ``x`` has more than one dimension, the function must</span>
<span class="sd">        flatten ``x`` and return the unique elements of the flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>

<span class="sd">        a namedtuple ``(values, inverse_indices)`` whose</span>

<span class="sd">        - first element must have the field name ``values`` and must be an array</span>
<span class="sd">          containing the unique elements of ``x``. The array must have the same data</span>
<span class="sd">          type as ``x``.</span>
<span class="sd">        - second element must have the field name ``inverse_indices`` and must be</span>
<span class="sd">          an array containing the indices of ``values`` that reconstruct ``x``.</span>
<span class="sd">          The array must have the same shape as ``x`` and must have the default</span>
<span class="sd">          array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.3,0.4,0.7,0.4,0.2,0.8,0.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_inverse()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    Results(values=ivy.array([0.2, 0.3, 0.4, 0.5, 0.7, 0.8]),</span>
<span class="sd">    inverse_indices=ivy.array([1, 2, 4, 2, 0, 5, 3]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unique_inverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<span class="c1">#ivy.array.sorting</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>

<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../../functional/ivy/sorting/argsort/argsort_array.html#ivy.array.array_methods.argsort">[docs]</a><span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argsort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.argsort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to sort. If set to ``-1``, the function</span>
<span class="sd">        must sort along the last axis. Default: ``-1``.</span>
<span class="sd">    descending</span>
<span class="sd">        sort order. If ``True``, the returned indices sort ``x`` in descending order</span>
<span class="sd">        (by value). If ``False``, the returned indices sort ``x`` in ascending order</span>
<span class="sd">        (by value). Default: ``False``.</span>
<span class="sd">    stable</span>
<span class="sd">        sort stability. If ``True``, the returned indices</span>
<span class="sd">        must maintain the relative order of ``x`` values</span>
<span class="sd">        which compare as equal. If ``False``, the returned</span>
<span class="sd">        indices may or may not maintain the relative order</span>
<span class="sd">        of ``x`` values which compare as equal (i.e., the</span>
<span class="sd">        relative order of ``x`` values which compare as</span>
<span class="sd">        equal is implementation-dependent). Default: ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out</span>
<span class="sd">        an array of indices. The returned array must have the same shape as ``x``.</span>
<span class="sd">        The returned array must have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 5, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 2, 0])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([9.6, 2.7, 5.2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0, 2, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../functional/ivy/sorting/sort/sort_array.html#ivy.array.array_methods.sort">[docs]</a><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([7, 8, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([8, 7, 6])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([8.5, 8.2, 7.6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([8.5, 8.2, 7.6])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="searchsorted"><a class="viewcode-back" href="../../../functional/ivy/sorting/searchsorted/searchsorted_array.html#ivy.array.array_methods.searchsorted">[docs]</a><span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ret_dtype</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.searchsorted.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.searchsorted also applies to this method with minimal changes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.statistical</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">abc</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../functional/ivy/statistical/min/min_array.html#ivy.array.array_methods.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the minimum value of the input array ``x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array. Should have a real-valued data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which minimum values must be computed.</span>
<span class="sd">        By default, the minimum value must be computed over the</span>
<span class="sd">        entire array. If a tuple of integers,minimum values must be</span>
<span class="sd">        computed over multiple axes. Default: ``None``.</span>

<span class="sd">    keepdims</span>
<span class="sd">        optional boolean, if ``True``, the reduced axes (dimensions)</span>
<span class="sd">        must be included in the result as singleton dimensions, and,</span>
<span class="sd">        accordingly, the result must be compatible with the input</span>
<span class="sd">        array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes (dimensions) must not be included in the</span>
<span class="sd">        result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the minimum value was computed over the entire array, a</span>
<span class="sd">        zero-dimensional array containing the minimum value; otherwise,</span>
<span class="sd">        a non-zero-dimensional array containing the minimum values.</span>
<span class="sd">        The returned array must have the same data type</span>
<span class="sd">        as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3., 4., 5.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.min()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(3.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1, 0, 1], [2, 3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.min(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1,  2])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.1, 1.1, 2.1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; x.min(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(0.1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../functional/ivy/statistical/max/max_array.html#ivy.array.array_methods.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.max. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.max also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which maximum values must be computed.</span>
<span class="sd">        By default, the maximum value must be computed over the</span>
<span class="sd">        entire array. If a tuple of integers, maximum values must</span>
<span class="sd">        be computed over multiple axes. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if ``True``, the reduced axes (dimensions) must be included</span>
<span class="sd">        in the result as singleton dimensions, and, accordingly, the</span>
<span class="sd">        result must be compatible with the input array</span>
<span class="sd">        (see :ref:`broadcasting`). Otherwise, if ``False``, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the maximum value was computed over the entire array,</span>
<span class="sd">        a zero-dimensional array containing the maximum value;</span>
<span class="sd">        otherwise, a non-zero-dimensional array</span>
<span class="sd">        containing the maximum values. The returned array must</span>
<span class="sd">        have the same data type</span>
<span class="sd">        as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x.max()</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(3)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.array([0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.max(out=z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(2)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 1, 2], [4, 6, 10]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.max(axis=0, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[4, 6, 10]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="mean"><a class="viewcode-back" href="../../../functional/ivy/statistical/mean/mean_array.html#ivy.array.array_methods.mean">[docs]</a><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.mean. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.mean also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    **Special Cases**</span>

<span class="sd">    Let ``N`` equal the number of elements over which to compute the</span>
<span class="sd">    arithmetic mean.</span>
<span class="sd">    -   If ``N`` is ``0``, the arithmetic mean is ``NaN``.</span>
<span class="sd">    -   If ``x_i`` is ``NaN``, the arithmetic mean is ``NaN`` (i.e., ``NaN``</span>
<span class="sd">        values propagate).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which arithmetic means must be computed. By default,</span>
<span class="sd">        the mean must be computed over the entire array. If a Sequence of</span>
<span class="sd">        integers, arithmetic means must be computed over multiple axes.</span>
<span class="sd">        Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        bool, if ``True``, the reduced axes (dimensions) must be included in the</span>
<span class="sd">        result as singleton dimensions, and, accordingly, the result must be</span>
<span class="sd">        compatible with the input array (see :ref:`broadcasting`). Otherwise,</span>
<span class="sd">        if ``False``, the reduced axes (dimensions) must not be included in</span>
<span class="sd">        the result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        array, if the arithmetic mean was computed over the entire array, a</span>
<span class="sd">        zero-dimensional array containing the arithmetic mean; otherwise, a</span>
<span class="sd">        non-zero-dimensional array containing the arithmetic means.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3., 4., 5.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.mean()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(4.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.mean(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(0.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.1, 1.1, 2.1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; x.mean(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(1.1)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3., 0., -1.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; ivy.mean(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(1.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-0.5, 1., 2.], [0.0, 1.1, 2.2]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; x.mean(axis=0, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0.25,  1.05,  2.1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.], [3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; ivy.mean(x, axis=1, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 4.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="var"><a class="viewcode-back" href="../../../functional/ivy/statistical/var/var_array.html#ivy.array.array_methods.var">[docs]</a><span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.var. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.var also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    **Special Cases**</span>

<span class="sd">    Let N equal the number of elements over which to compute the variance.</span>

<span class="sd">    If N - correction is less than or equal to 0, the variance is NaN.</span>

<span class="sd">    If x_i is NaN, the variance is NaN (i.e., NaN values propagate).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which variances must be computed. By default, the</span>
<span class="sd">        variance must be computed over the entire array. If a tuple of integers,</span>
<span class="sd">        variances must be computed over multiple axes. Default: ``None``.</span>
<span class="sd">    correction</span>
<span class="sd">        degrees of freedom adjustment. Setting this parameter to a value other</span>
<span class="sd">        than 0 has the effect of adjusting the divisor during the calculation</span>
<span class="sd">        of the variance according to N-c where N corresponds to the total</span>
<span class="sd">        number of elements over which the variance is computed and c corresponds</span>
<span class="sd">        to the provided degrees of freedom adjustment. When computing the variance</span>
<span class="sd">        of a population, setting this parameter to 0 is the standard choice</span>
<span class="sd">        (i.e., the provided array contains data constituting an entire population).</span>
<span class="sd">        When computing the unbiased sample variance, setting this parameter to 1</span>
<span class="sd">        is the standard choice (i.e., the provided array contains data sampled</span>
<span class="sd">        from a larger population; this is commonly referred to as Bessel&#39;s</span>
<span class="sd">        correction). Default: ``0``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible</span>
<span class="sd">        with the input array (see Broadcasting). Otherwise, if False, the</span>
<span class="sd">        reduced axes (dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the variance was computed over the entire array, a zero-dimensional array</span>
<span class="sd">        containing the variance; otherwise, a non-zero-dimensional array containing</span>
<span class="sd">        the variances. The returned array must have the same data type as x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0, 1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0, 5.0],</span>
<span class="sd">    ...                [6.0, 7.0, 8.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.var()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(6.6666665)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0, 1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0, 5.0],</span>
<span class="sd">    ...                [6.0, 7.0, .08]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.var(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6., 6., 4.1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0, 1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0, 5.0],</span>
<span class="sd">    ...                [6.0, 7.0, .08]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; x.var(axis=1, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.667, 0.667, 9.33 ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="prod"><a class="viewcode-back" href="../../../functional/ivy/statistical/prod/prod_array.html#ivy.array.array_methods.prod">[docs]</a><span class="k">def</span> <span class="nf">prod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../../functional/ivy/statistical/sum/sum_array.html#ivy.array.array_methods.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="std"><a class="viewcode-back" href="../../../functional/ivy/statistical/std/std_array.html#ivy.array.array_methods.std">[docs]</a><span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cumsum"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumsum/cumsum_array.html#ivy.array.array_methods.cumsum">[docs]</a><span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cumsum. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cumsum also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to apply cumsum.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative sum is computed. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to perform cumsum exclusively. Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumsum from last to first element in the selected</span>
<span class="sd">        axis. Default is ``False`` (from first to last element)</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array container. Default is ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array which holds the result of applying cumsum at each</span>
<span class="sd">        original array elements along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 1,  3,  6, 10, 15])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2, 6, 4, 10])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=0, exclusive=False, reverse=True, dtype=&#39;float64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([22., 20., 14., 10.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2, 3], [4, 6], [8, 12]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=1, exclusive=True, reverse=False, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0, 2],</span>
<span class="sd">               [0, 4],</span>
<span class="sd">               [0, 8]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 5, 2],</span>
<span class="sd">    ...                [4, 3, 0],</span>
<span class="sd">    ...                [4, 8, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=1, exclusive=True, reverse=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 7,  2,  0],</span>
<span class="sd">               [ 3,  0,  0],</span>
<span class="sd">               [10,  2,  0]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 5, 10], [4, 8, 10], [2, 3, 5]])</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[ 1,  5, 10],</span>
<span class="sd">               [ 5, 13, 20],</span>
<span class="sd">               [ 7, 16, 25]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cumprod"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumprod/cumprod_array.html#ivy.array.array_methods.cumprod">[docs]</a><span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cumprod. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cumprod also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    axis</span>
<span class="sd">        int, axis along which to take the cumulative product. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        optional bool, whether to exclude the first value of the input array.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumprod from last to first element in the selected</span>
<span class="sd">        axis. Default is ``False`` (from first to last element)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Input array with cumulatively multiplied elements along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumprod()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 2, 6, 24, 120])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2, 3], [5, 7], [11, 13]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros((3, 2), dtype=&quot;int32&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x.cumprod(axis=1, exclusive=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0, 0],</span>
<span class="sd">               [0, 0],</span>
<span class="sd">               [0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einsum"><a class="viewcode-back" href="../../../functional/ivy/statistical/einsum/einsum_array.html#ivy.array.array_methods.einsum">[docs]</a><span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">equation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.utility</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">abc</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="all"><a class="viewcode-back" href="../../../functional/ivy/utility/all/all_array.html#ivy.array.array_methods.all">[docs]</a><span class="k">def</span> <span class="nf">all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.all. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical AND reduction. By default, a</span>
<span class="sd">        logical AND reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical AND reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default  ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical AND reduction was performed over the entire array, the returned</span>
<span class="sd">        array must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned array must be a non-zero-dimensional array</span>
<span class="sd">        containing the test results. The returned array must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.all()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="any"><a class="viewcode-back" href="../../../functional/ivy/utility/any/any_array.html#ivy.array.array_methods.any">[docs]</a><span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.any. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.any also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical OR reduction. By default, a</span>
<span class="sd">        logical OR reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical OR reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical OR reduction was performed over the entire array, the returned</span>
<span class="sd">        array must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned array must be a non-zero-dimensional array</span>
<span class="sd">        containing the test results. The returned array must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.any()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.array.wrapping</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="n">TO_IGNORE</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_wrap_function</span><span class="p">(</span><span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Wraps the function called `function_name`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function_name</span>
<span class="sd">        the name of the function e.g. &quot;abs&quot;, &quot;mean&quot; etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_function</span>
<span class="sd">        the wrapped function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ivy.set_backend(&quot;torch&quot;)</span>
<span class="sd">    &gt;&gt;&gt; from ivy.array.wrapping import _wrap_function</span>
<span class="sd">    &gt;&gt;&gt; absolute = _wrap_function(&quot;abs&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1])</span>
<span class="sd">    &gt;&gt;&gt; print(absolute(x))</span>
<span class="sd">    ivy.array([1])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">new_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the data of the current array from which the instance function is invoked</span>
<span class="sd">        as the first arg parameter or kwarg parameter. Return the new function with</span>
<span class="sd">        the name function_name and the new args variable or kwargs as the new inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span>
        <span class="c1"># gives us the position and name of the array argument</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">array_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">]</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">]</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_function</span>


<span class="k">def</span> <span class="nf">add_ivy_array_instance_methods</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">modules</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ModuleType</span><span class="p">],</span> <span class="n">to_ignore</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="p">()</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loop over all ivy modules such as activations, general, etc. and add</span>
<span class="sd">    the module functions to ivy arrays as instance methods using _wrap_function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls</span>
<span class="sd">        the class we want to add the instance methods to.</span>
<span class="sd">    modules</span>
<span class="sd">        the modules to loop over: activations, general etc.</span>
<span class="sd">    to_ignore</span>
<span class="sd">        any items we don&#39;t want to add an instance method for.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    As shown, `add_ivy_array_instance_methods` adds all the appropriate functions from</span>
<span class="sd">    the activations module as instance methods to our toy `ArrayExample` class:</span>

<span class="sd">    &gt;&gt;&gt; from ivy.functional.ivy import activations</span>
<span class="sd">    &gt;&gt;&gt; class ArrayExample:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; ivy.add_ivy_array_instance_methods(ArrayExample, [activations])</span>
<span class="sd">    &gt;&gt;&gt; print(hasattr(ArrayExample, &quot;relu&quot;), hasattr(ArrayExample, &quot;softmax&quot;))</span>
<span class="sd">    True True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">to_ignore</span> <span class="o">=</span> <span class="n">TO_IGNORE</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_ignore</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># we skip the cases where the function is protected, the instance</span>
            <span class="c1"># method has already been added manually and a few other cases</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span>
                <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">to_ignore</span>
                <span class="ow">or</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_wrap_function</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, Ivy Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>